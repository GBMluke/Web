认证与会议管理

	用户是谁
		认证是最容易理解的一种安全，如果一个系统缺乏认证手段，明眼人都能看出来这是不安全的，最常见的认证方式就是用户名与密码，但认证的手段却远远不止于此
		很多时候，人们会把认证和授权两个概念搞混，甚至有些安全工程师也是如此
		实际上认证和授权是两件事情，认证的英文是Authentication，授权则是Authorization
		分清楚这两个概念其实很简单，只需要记住下面这个事实
			认证的目的是为了认出用户是谁
			授权的目的是为了决定用户能够做什么
		凭证(Creden-tial)
		登录(Login)
		用Creden-tial Login(Authentication)后，什么事情能做，什么事情不能做，Authorization就是的管辖范围了
		能否进入后台这个权限的前提，是需要识别出来到底是管理员还是访客
		当有人仿照了一个Creden-tial，就有可能认错人了
		这些异常情况，就是因为认证出现了问题，系统的安全直接受到了威胁
		认证的手段是多样化的，其目的就是为了能够识别出正确的人
		如何才能准确地判断一个人是谁呢?这是一个哲学问题，在被哲学家们搞清楚之前，我们只能够依据人的不同凭证来确定一个人的身份
		单一密码很脆弱的凭证， 其他诸如指纹、虹膜、人脸、声音等生物特征也能够作为识别一个人的凭证
		认证实际上就是一个验证凭证的过程
		如果只有一个凭证被用于认证，则称为单因素认证
		如果有两个或多个凭证被用于认证，则称为双因素(Two Factors)认证或多因素认证
		一般来说，多因素认证的强度要高于单因素认证，但是在用户体验上，多因素认证或多或少都会带来一些不方便的地方

	密码

		Burp Suite简介
			Burp Suite是进行Web应用安全测试集成平台
			它将各种安全工具无缝地融合在一起，以支持整个测试过程中，从最初的映射和应用程序的攻击面分析，到发现和利用安全漏洞
			Burp Suite结合先进的手工技术与先进的自动化，使你的工作更快，更有效，更有趣
			在安全人员常用工具表(http://sectools.org/)中，burpsuite排在第13位，且排名在不断上升，由此可见它在安全人员手中的重要性
			Burp Suite的模块几乎包含整个安全测试过程，从最初对目标程序的信息采集，到漏洞扫描及其利用，多模块间高融合的配合，使得安全测试的过程更加高效

		主要模块
			* Target(目标)——显示目标目录结构的的一个功能
			* Proxy(代理)——拦截HTTP/S的代理服务器，作为一个在浏览器和目标应用程序之间的中间人，允许你拦截，查看，修改在两个方向上的原始数据流
			* Spider(蜘蛛)——应用智能感应的网络爬虫，它能完整的枚举应用程序的内容和功能
			* Scanner(扫描器)——高级工具，执行后，它能自动地发现web 应用程序的安全漏洞
			* Intruder(入侵)——一个定制的高度可配置的工具，对web应用程序进行自动化攻击
			* Repeater(中继器)——一个靠手动操作来触发单独的HTTP 请求，并分析应用程序响应的工具
			* Sequencer(会话)——用来分析那些不可预知的应用程序会话令牌和重要数据项的随机性的工具
			* Decoder(解码器)——进行手动执行或对应用程序数据者智能解码编码的工具
			* Comparer(对比)——通常是通过一些相关的请求和响应得到两项数据的一个可视化的差异
			* Extender(扩展)——可以让你加载Burp Suite的扩展，使用你自己的或第三方代码来扩展Burp Suit的功能
			* Options(设置)——对Burp Suite的一些设置
			* Alerts(警告)——Burp Suite在运行过程中发生的一写错误

		burpsuite基本介绍及环境配置
			http://bbs.ichunqiu.com/thread-15805-1-1.html

		Proxy模块(代理模块)
			http://bbs.ichunqiu.com/thread-15806-1-1.html

		[实验篇]Proxy模块(代理模块)
			http://bbs.ichunqiu.com/thread-15807-1-1.html

		Spider模块(蜘蛛爬行)
		    http://bbs.ichunqiu.com/thread-15864-1-1.html

		[实验篇]Spider模块应用之目录爬行
			http://bbs.ichunqiu.com/thread-15865-1-1.html

		Scanner模块(漏洞扫描)
			http://bbs.ichunqiu.com/thread-16258-1-1.html
	
		密码是最常见的一种认证手段，持有正确密码的人被认为是可信的
		长期以来，桌面软件、互联网都普遍以密码作为最基础的认证手段
		优点
			使用成本低，认证过程实现起来很简单
		缺点
			密码认证是一种比较弱的安全方案，可能会被猜解，要实现一个足够安全的密码认证方案，也不是一件轻松的事情
		密码强度是设计密码认证方案时第一个需要考虑的问题
		在用户密码强度的选择上，每个网站都有自己的策略
		目前并没有一个标准的密码策略，但是根据OWASP推荐的一些最佳实践，我们可以对密码策略稍作总结
			http://www.owasp.org
			长度限制
				* 普通应用要求长度为6位以上
				* 重要应用要求长度为8位以上，并考虑双因素认证
			复杂度限制
				* 密码区分大小写字母
				* 密码为大写字母、小写字母、数字、特殊符号中两种以上的组合
				* 不要有连续性的字符，这种字符顺着人的思路，所以很容易猜解
				* 尽量避免出现重复的字符
			除了OWASP推荐的策略外，还需要注意，不要使用用户的公开数据，或者是与个人隐私相关的数据作为密码
			比如不要使用 QQ号、身份证号码、昵称、电话号码(含手机号码)、生日、 英文名、公司名等作为密码，这些资料往往可以从互联网上获得，并不是那么保密
			微博网站Twitter在用户注册的过程中，列出了一份长达300个单词的弱密码列表，如果用户使用的密码被包含在这个列表中，则会提示用户此密码不安全
			目前黑客们常用的一种暴力破解手段，不是破解密码，而是选择一些弱口令
			然后猜解用户名，直到发现一个 使用弱口令的账户为止
			由于用户名往往是公开的信息，攻击者可以收集一份用户名的字典，使得这种攻击的成本非常低，而效果却比暴力破解密码要好很多
			密码的保存也有一些需要注意的地方
				一般来说，密码必须以不可逆的加密算法，或者是单向散列函数算法，加密后存储在数据库中
				这样做是为了尽最大可能地保证密码的私密性
				即使是网站的管理人员，也不能够看到用户的密码
				在这种情况下，黑客即使入侵了网站，导出了数据库中的数据，也无法获取到密码的明文
				国内最大的开发者社区CSDN的数据库被黑客公布在网上
				令人震惊的是，CSDN将用户的密码明文保存在数据库中，致使600万用户的密码被泄露
				明文保存密码的后果很严重
					黑客们曾经利用这些用户名与密码，尝试登录了包括QQ、 人人网、新浪微博、支付宝等在内的很多大型网站，致使数以万计的用户处于风险中
				一个提供彩虹表查询的MD5破解网站为了避免密码哈希值泄露后，黑客能够直接通过彩虹表查询出密码明文，在计算密码明文的哈希值时，增加一个Salt
				Salt是一个字符串，它的作用是为了增加明文的复杂度，并能使得彩虹表一类的攻击失效
				Salt应该保存在服务器端的配置文件中，并妥善保管
				
	多因素认证
		对于很多重要的系统来说，如果只有密码作为唯一的认证手段，从安全上看会略显不足
		因此为了增强安全性，大多数网上银行和网上支付平台都会采用双因素认证或多因素认证
		除了支付密码外，手机动态口令、数字证书、宝令、支付盾、第三方证书等都可用于用户认证
		这些不同的认证手段可以互相结合，使得认证的过程更加安全
		密码不再是唯一的认证手段，在用户密码丢失的情况下，也有可能有效地保护用户账户的安全
		多因素认证提高了攻击的门槛
		比如一个支付交易使用了密码与数字证书双因素认证，成功完成该交易必须满足两个条件
			密码正确
			进行支付的电脑必须安装了该用户的数字证书
		因此，为了成功实施攻击，黑客们除了盗取用户密码外，还不得不想办法在用户电脑上完成支付，这样就大大提高了攻击的成本
			e.g.支付宝
				http://alipay.com

	Session与认证
		密码与证书等认证手段，一般仅仅用于登录(Login)的过程
		当登录完成后，用户访问网站的页面，不可能每次浏览器请求页面时都再使用密码认证一次
		因此，当认证成功后，就需要替换一个对用户透明的凭证
		这个凭证，就是SessionID
		当用户登录完成后，在服务器端就会创建一个新的会话(Session)，会话中会保存用户的状态和相关信息
		服务器端维护所有在线用户的Session，此时的认证，只需要知道是哪个用户在浏览当前的页面即可
		为了告诉服务器应该使用哪一个Ses-sion，浏览器需要把当前用户持有的SessionID告知服务器
		最常见的做法就是把SessionID加密后保存在Cookie中，因为 Cookie会随着HTTP请求头发送，且受到浏览器同源策略的保护 *浏览器安全*
		Cookie中保存的SessionID
		SessionID一旦在生命周期内被窃取，就等同于账户失窃
		同时由于SessionID是用户登录之后才持有的认证凭证，因此黑客不需要再攻击登录过程(比如密码)，在设计安全方案时需要意识到这一点
		Session劫持就是一种通过窃取用户Ses-sionID后，使用该SessionID登录进目标账户的攻击方法，此时攻击者实际上是使用了目标账户的有效Session
		如果SessionID是保存在Cookie中的，则这种攻击可以称为Cookie劫持
		Cookie泄露的途径有很多，最常见的有XSS攻击、网络Sniff，以及本地木马窃取
		对于通过XSS漏洞窃取Cookie的攻击，通过给Cookie标记httponly，可以有效地缓解XSS窃取Cookie的问题
		但是其他的泄露途径，比如网络被嗅探，或者Cookie文件被窃取，则会涉及客户端的环境安全，需要从客户端着手解决
		SessionID除了可以保存在Cookie中外，还可以保存在URL中，作为请求的一个参数
		但是这种方式的安全性难以经受考验
		在手机操作系统中，由于很多手机浏览器暂不支持Cookie，所以只能将SessionID作为URL的一个参数用于认证
		安全研究者kxlzx曾经在博客上列出过一些无线WAP中因为sid泄露所导致的安全漏洞
			https://inbreak.net
		其中一个典型的场景就是通过Ref-erer泄露URL中的sid，QQ的WAP邮箱曾经出过此漏洞
			https://www.inbreak.net/archives/287
		在生成SessionID时，需要保证足够的随机性，比如采用足够强的伪随机数生成算法
		现在的网站开发中，都有很多成熟的开发框架可以使用
		这些成熟的开发框架一般都会提供Cookie管理、Session管理的函数，可以善用这些函数和功能

	Session Fixation攻击
		A把一个账户卖给了B，但A仍然有原有密码，如果B不更换密码，就会导致安全问题，这就是Session Fixation问题
		攻击的过程是，攻击者先获取到一个未经认证的SessionID，然后将这个SessionID交给用户去认证，用户完成认证后，服务器并未更新此SessionID的值(注意是未改变SessionID，而不是未改变Session)，所以攻击者可以直接凭借此SessionID登录进用户的账户
		如果SessionID保存在Cookie中，比较难做到这一点，但若是SessionID保存在URL中，则攻击者只需要诱使用户打开这个URL即可
		在上一节中提到的sid，就需要认真考虑Session Fixation攻击
		解决Session Fixation的正确做法是，在登录完成后，重写SessionID
		如果使用sid则需要重置sid的值，如果使用Cookie，则需要增加或改变用于认证的Cookie值
		值得庆幸的是，在今天使用Cookie才是互联网的主流，sid的方式渐渐被淘汰
		而由于网站想保存到Cookie中的东西变得越来越多，因此用户登录后，网站将一些数据保存到关键的Cookie中，已经成为一种比较普遍的做法
		Session Fixation攻击的用武之地也就变得越来越小了

	Session保持攻击
		一般来说，Session是有生命周期的，当用户长时间未活动后，或者用户点击退出后，服务器将销毁Session
		但如果攻击者能一直持有一个有效的Session(比如间隔性地刷新页面以告诉服务器这个用户仍然在活动)，而服务器对于活动的Session也一直不销毁的话，攻击者就能通过此有效Session—直使用用户的账户，成为一个永久的后门
		一般的应用都会给session设置一个失效时间，当到达失效时间后，Session将被销毁
		但有一些系统，出于用户体验的考虑，只要这个用户还活着，就不会让这个用户的Session失效
		从而攻击者可以通过不停地发起访问请求，让Session一直活下去
		安全研究者kxlzx曾经分享过这样的一个案例
			http://www.inbreak.net/archives/174
		而Cookie是可以完全由客户端控制的，通过发送带有自定义Cookie头的HTTP包，也能实现同样的效果
		安全研究者cnqing曾经开发过一个叫SessionIE的工具，其中就实现了Session状态的保持
		在Web开发中，网站访问量如果比较大，维护Session可能会给网站带来巨大的负担
		因此，有一种做法，就是服务器端不维护Session，而把Session放在Cookie中加密保存
		当浏览器访问网站时，会自动带上Cookie，服务器端只需要解密Cookie即可得到当前用户的Session了
		很多应用都是利用Cookie的Expire标签来控制Session的失效时间，这就给了攻击者可乘之机
		Cookie的Expire时间是完全可以由客户端控制的
		篡改这个时间，并使之永久有效，就有可能获得一个永久有效的Session，而服务器端是完全无法察觉的
		攻击者甚至可以为Session Cookie增加一个Expire时间，使得原本浏览器关闭就会失效的Cookie持久化地保存在本地，变成一个第三方Cookie(third-party cookie)
		对抗方法
			常见的做法是在一定时间后，强制销毁Session
			这个时间可以是从用户登录的时间算起，设定一个阈值，比如3天后就强制Session过期
			但强制销毁Session可能会影响到一些正常的用户，还可以选择的方法是当用户客户端发生变化时，要求用户重新登录
			比如用户的IP、UserAgent等信息发生了变化，就可以强制销毁当前的Session，并要求用户重新登录
			最后，还需要考虑的是同一用户可以同时拥有几个有效Session
			若每个用户只允许拥有一个Session，则攻击者想要一直保持一个Session也是不太可能的
			当用户再次登录时，攻击者所保持的Session将被踢出

	单点登录(SSO)
		单点登录的英文全称是Single Sign On，简称SSO，它希望用户只需要登录一次，就可以访问所有的系统
		从用户体验的角度看，SSO无疑让用户的使用更加的方便
		从安全的角度看，SSO把风险集中在单点上，这样做是有利有弊的
		SSO的优点在于风险集中化，就只需要保护好这一个点
		如果让每个系统各自实现登录功能，由于各系统的产品需求、应用环境、开发工程师的水平都存在差异，登录功能的安全标准难以统一，而SSO解决了这个问题，它把用户登录的过程集中在一个地方
		在单点处设计安全方案，甚至可以考虑使用一些较重的方法，比如双因素认证
		此外对于一些中小网站来说，维护一份用户名、密码也是没有太大必要的开销，所以如果能将这个工作委托给一个可以信任的第三方，就可以将精力集中在业务上
		SSO的缺点同样也很明显，因为风险集中了，所以单点一旦被攻破的话，后果会非常严重，影响的范围将涉及所有使用单点登录的系统
		降低这种风险的办法是在一些敏感的系统里，再单独实现一些额外的认证机制
		比如网上支付平台，在付款前要求用户再输入一次密码，或者通过手机短信验证用户身份等
		目前互联网上最为开放和流行的单点登录系统是OpenID
		OpenID是一个开放的单点登录框架，它希望使用URI作为用户在互联网上的身份标识，每个用户(End User)将拥有一个唯一的URI
		在用户登录网站(Relying Party)时，用户只需要提交他的OpenID(就是用户唯一的URI)以及OpenID的提供者(OpenID Provider)，网站就会将用户重定向到OpenID的提供者进行认证，认证完成后再重定向回网站
		OpenID模式仍然存在一些问题
			OpenID的提供者服务水平也有高有低，作为OpenID的提供者，一旦网站中断服务或者关闭，都将给用户带来很大的不便
			因此目前大部分网站仍然是很谨慎地使用OpenID，而仅仅是将其作为一种辅助或者可选的登录模式，这也限制了OpenID的发展

	总结
		认证的手段是丰富多彩的
			在互联网中，除了密码可以用于认证外，还有很多新的认证方式可供使用
			我们也可以组合使用各种认证手段，以双因素认证或多因素认证的方式，提高系统的安全强度
		在Web应用中，用户登录之后，服务器端通常会建立一个新的Session以跟踪用户的状态
		每个Session对应一个标识符SessionID，SessionID用来标识用户身份，一般是加密保存在Cookie中
		有的网站也会将Session保存在Cookie中，以减轻服务器端维护Session的压力
		围绕着Session可能会产生很多安全问题，这些问题都是在设计安全方案时需要考虑到的
