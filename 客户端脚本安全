	「第二篇」客户端脚本安全

		0.6本书结构
			就当前比较流行的客户端脚本攻击进行了深入阐述，当网站的安全做到一定程度后，黑客很难找到类似注入攻击、脚本执行等高风险的漏洞，从而可能将注意力转义到客户端脚本攻击上
			客户端脚本安全于浏览器的特性息息相关，因此对浏览器的深入理解将有助于做好客户端脚本安全的解决方案

		「第二章」浏览器安全

			「2.1同源策略」
				Same Origin Policy
				是一种约定，它是浏览器最核心、最基本的安全功能，如果缺少了同源策略，浏览器的正常功能可能都会受到影响
				可以说，Web是建立在同源策略之上的
				浏览器的同源策略限制了来自不同源的document或脚本，对当前document读取或设置某些属性
				对于JavaScript来说，不同的URL会被分为同源与不同源
					影响原因：host(域名/IP地址)、子域名、端口、协议
				XMLHttpRequest可以访问同源对象的内容,但同样收到同源的约束，使其不能跨越访问资源，在AJAX应用的开发中尤其注意这一点
				除了DOM、Cookie、XMLHttpRequest会受到同源策略的限制，浏览器加载的一些第三方插件也有各自的同源策略。
					最常见的是Flash、Java Applet、Silverlight、Google Gears都有自己的控制策略
				浏览器的同源策略是浏览器安全的基础，许多客户端脚本攻击，都需要遵守这一原则
					因此理解同源策略对于客户端脚本攻击有着重要意义
					同源策略一旦被出现的漏洞绕过，也将带来非常严重的后果，很多基于同源策略制定的安全方案将失去效果
				[同源是指域名、协议、端口相同]
				[同源策略，它是由Netscape提出的一个著名的安全策略]
				[同源策略是浏览器的行为，是为了保护本地数据不被JavaScript代码获取回来的数据污染，因此拦截的是客户端发出的请求回来的数据接收，即请求发送了，服务器响应了，但是无法被浏览器接收]

			「2.2浏览器沙箱」
				在网页中插入一段恶意代码，利用浏览器漏洞执行任意代码的攻击方式，在黑客圈子里被形象地称为挂马
				防挂马操作
					浏览器密切结合DEP、ASLR、SafeSEH等保护系统
				Google Chrome流程
					浏览器进程
					渲染进程
						由Sandbox即沙箱隔离
					插件进程
						e.g.:将Flash、Java、Pdf进行隔离，因此不会相互影响
					扩展进程
				现在的Sandbox已经成为泛指资源隔离类模块的代名词
				Sandbox的设计目的一般是为了让不可信任的代码运行在一定的环境中，限制不可信任的代码访问隔离区之外的资源
				现在了浏览器的内部结构文件已经受到Sandbox的保护，但第三方应用却不受Sandbox的管辖，所以被攻克的浏览器往往是第三方应用的安全漏洞
				[
					Sandbox是指一种技术，在这种技术中，软件运行在操作系统受限制的环境中
					由于该软件在受限制的环境中运行，即使一个闯入该软件的入侵者也不能无限制访问操作系统提供设施
					获得该软件控制权的黑客造成的损失也是有限的
					如果攻击者要获得对操作系统的完全控制，他们就不得不攻克沙箱限制，Sandbox也提供深度防御
					许多PaaS系统都提供了一个实时运行环境，它的核心就是一个沙箱应用程序
					如Azu re和Google App Engime
				]

			「2.3恶意网址拦截」
				工作原理
					一般都是浏览器周期性地从服务器获取一份最新的恶意网址黑名单，如果用户上网时访问的网址在黑名单中，浏览器将弹出警告
				常见的恶意网址分类
					1.挂马的网站，这些网站通常包含有恶意的脚本，如JavaScript或Flash，通过利用浏览器的漏洞执行shellcode，在用户电脑中植入木马
					2.钓鱼网站，通过模仿知名网站的相似页面来欺骗用户
				除了恶意网址黑名单拦截功能外，主流浏览器都开始支持EV SSL(Extended Validation SSL Certificate)证书，以增强对安全网址的识别
				[EV SSL证书是全球数字证书颁发机构与浏览器厂商一起打造的增强型证书]
				其主要特色是浏览器会给予EV SSL证书特殊的待遇
				EV SSL证书也遵循X509标准，并向前兼容普通证书
				如果浏览器不支持EV模式，则会把该证书当作普通证书
				如果浏览器支持EV模式，则会在地址栏中特别标注、
				因此在网站使用了EV SSL证书后，可以教育用户识别真实网站在浏览器地址栏中的绿色表现，以对抗钓鱼网站

			「2.4高速发展的浏览器安全」
				现在的浏览器还在不断地更新，不断地推出新的安全功能
				CSP(Content Security Policy)
					这一策略是由安全专家Robert Hanson最早提出的
					做法
						由一个服务器返回一个HTTP头，并在其中描述页面应该遵守的安全策略
				浏览器加载的插件也是浏览器安全需要考虑的一个问题
					扩展与插件的权限到高于页面JavaScript的权限

			「2.5总结」
				浏览器是互联网安全的重要接口，在安全攻防中，浏览器的作用也越来越被人们重视
				在以往研究攻防时，大家更重视服务器端漏洞，现在，安全研究的范围已经涵盖了所有用户使用互联网的方式，浏览器正是其中最重要的一个部分
				加深理解同源策略，才能把握浏览器安全的本质
				随着信息技术的发展，恶意网址检测、插件安全等问题都会显得越来越重要

		「第三章」跨站脚本攻击(XSS)
			[
				0x00转义字符
					首先要认识一下\，\在JavaScript有着特殊的用途，它是转义的符号
					e.g.
						\x3C\x73\x63\x72\x69\x70\x74\x3E\x61\x6C\x65\x72\x74\x28\x27\x70\x6F\x72\x75\x69\x6E\x27\x29\x3C\x2F\x73\x63\x72\x69\x70\x74\x3E
					这些就是经过编码后的字符，因为前面的\缘故，所以后面的这些字符在JavaScript中都会被还原
					接受用户的数据后过滤<>，再用JavaScript显示出来，输入经过16进制转换后的字符，这些字符都可以轻松的绕过过滤，完整进入代码中，经过JavaScript还原之后，正确解释出来
				0x01UBB标签
					UBB标签是目前广泛运用到论坛，留言簿，以及其他网站系统的一种编码标签，类似[img]url[/img]这样的，用户在中间输入地址后即可，在发表的时候系统会自动改成<img src=”url”></img>，这个URL就是用户输入的图片地址，XSS攻击中，可以利用这个特点来达到无需用户输入<>就能执行由用户所输入的代码，我们只要在输入网址的地方输入：
						x"/**/οnerrοr="alert(‘poruin’)
					那么经过转换后就变成了
						<img src=“x”/**/οnerrοr=“alert(‘poruin’)”>
				0x02
					JS中的编码还原函数最常用的就是String.fromCharCode了，这个函数用于ASCII码的还原，一般来说，这个函数都要配合eval()来使用才有效果。
					在跨站中，String.fromCharCode主要是使到一些已经被列入黑名单的关键字或语句安全通过检测，把关键字或语句转换成为ASCII码，然后再用String.fromCharCode还原，因为大多数的过滤系统都不会把String.fromCharCode加以过滤，例如关键字alert被过滤掉，那就可以这么利用：
						<img src=“x”/**/οnerrοr=“eval(String.fromCharCode(97,108,101,114,116,40,39,112,111,114,117,105,110,39,41))”>
			]
			[
				0x00前端过滤
					burp抓包改包绕过
				0x01双写绕过
				0x02事件绕过
					onclick
					onmousemove
				0x03大小写绕过
				0x04注释干扰绕过
					<scri<!--test-->pt>alert(1),<scr<!--teat-->ipt>
				0x05伪协议绕过
					111">a href="javascript:alert(document.domain)">xss</a>
					<table background="javascript:alert(/xss/)"></table>
					<img src ="javascript:alert('xss';")>
				0x06空格回车Tab绕过
					空格
						<img src="jav    ascript:alert('xss');">
					Tab
						<img src="javasc	ript:alert('xss');">
					回车
						<img src="jav
						ascript:
						alert('xss'):">
				0x07编码绕过
					base64编码
						eval("")eval函数把字符串当作程序执行
						atob函数是将base64密文转换为明文
						"><script>eval(atob('YWxlcnQoZG9tYWluKQ=='));</script>
						base64编码多用于如下两种情况
							<a herf="可控点">
							<iframe src="可控点">
						如果过滤了<、>、'、"、script，可以使用base64编码
						<a herf="data:text/html;base64,PGItZyBzcmM9eCBvbmVycm9yPWFsCXJ0KDEpPg==">test</a>
						这样当tast A链接点击时，就会以data协议，页面以html/test的方式解析，编码为base64，然后点击a链接时，base64的编码就被还原成原本的<img src=x onerror=alert(1)>
					JS编码
						八进制
							三个八进制数字，如果不够，在前面补0
							e.g.
								e = \145
						十六进制
							两个十六进制数字，如果不够，在前面补0
							e.g.
								e = \x65
							十六进制前面加\x可以被JS识别
							<>被转义时，利用十六进制绕过
								\\x3cscript\\x3ealert(document.domain);\\x3c/script\\x3e
						Unicode
							四个十六进制数字，如果不够，在前面补0
							e.g.
								e = \u0065
							十六进制前面加\u00变成可被JS识别的Unicode编码
							\\uoo3cscript\\u003ealert(document.domain);\\u003c/script\\u003e
						对于一些控制字符，使用特殊的C类型的转义风格(\r、\n)
					HTML实体编码
						字符编码
							十进制、十六进制编码，样式为"&#数值;"
							{浏览器是不会在html标签里解析js编码的，所以我们在onerror=后面放js中的编码是不会被解析，你放进去是什么，就是什么}
							HTML5新增的实体命名编码
								&colon; = [:]
								&NewLine; = [Line feed]
								<a href="javasc&NewLine;ript&colon;alert(1)">click</a>
					URL编码
						进行两次URL前编码
				0x08CSS
					利用IE特性绕过
						IE中‘’可以闭合一个“
						"onmousemove=alert(1)
					利用CSS特性绕过
						设置background:url，利用JavaScript伪协议执行js
						background-color:#f00;background:url("javascript:alert(document.domain);");
					IE中利用CSS出发xss
						CSS中的注视/**/
						xss:expres/**/sion(if(!window.x){alert(document.domain);window.x=1;})
			]
			「3.1XSS简介」
				XSS(Cross Site Script)跨站脚本攻击
				XSS攻击通常指黑客通过HTML注入篡改了网页，插入了恶意脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击
				因为在最开始的时候XSS攻击的演示案例首跨域对，所以叫跨站脚本
				分类
					1.反射型XSS
						简单地把用户输入的数据反射给服务器
						黑客需要诱惑用户点击一个恶意链接，才能完成攻击
						又称非持久型XSS(Non-persistent XSS)
						[前端--->后端--->前端]
					2.存储型XSS
						把用户输入的数据存储在服务器端
						具有很强的稳定性
						又称持久型XSS(Persistent XSS)
						[前端--->后端--->数据库--->前端]
					3.DOM Based XSS(DOM型XSS)
						通过修改页面的DOM节点形成的XSS
						[前端]

			「3.2XSS攻击进阶」
				3.2.1初探XSS Payload
					XSS攻击成功后，攻击者能够对用户当前浏览的页面植入恶意脚本，通过恶意脚本，控制用户的浏览器
					这些用以完成各种具体功能的恶意脚本，被称为XSS Payload
					XSS Payload实际上就是JavaScript脚本，还可以是Flash或其他富客户端的脚本，所以JavaScript能做到的功能，XSS Payload也能做到
					一个最常见的XSS Payload就是通过读取浏览器的Cookie对象，从而发起Cookie劫持的攻击
					Cookie中一般加密保存了当前用户的登录凭证，如果Cookie丢失，就意味着用户的登录凭证丢失，攻击者就可以不通过密码，直接进入用户的账户

				3.2.2强大的XSSPayload
					3.2.2.1构造GET与POST请求
						一个网站的应用只需要接受HTTP协议中的GET或POST请求，即可完成所有操作
						对于攻击者来说，仅通过JavaScript就可以让浏览器发起这两个请求
						所以XSS攻击后，攻击者除了可以实施Cookie劫持外，还能够通过模拟GET、POST请求操作用户的浏览器
							这在某些隔离环境中会非常有用，比如Cookie劫持失效时，或者目标用户的网络不能访问互联网等情况

					3.2.2.2XSS钓鱼
						将XSS与钓鱼结合的思路
							利用JavaScript在当前界面伪造一个登录框，当用户在登录框中输入用户名与密码后，其密码会发送到黑客的服务器上
						充分发挥想象力，可以使XSS攻击的威力更加巨大

					3.2.2.3识别用户浏览器
						在很多时候，攻击者为了获取更大的利益，往往需要准确地手机用户的个人信息
						但是浏览器的UserAgent是可以伪造的，所以通过JavaScript取出来的这个浏览器对象，信息并不一定准确
						由于浏览器之间的实现存在差异——不同的浏览器会各自实现一些独特的功能，而同一个浏览器的不同版本之间也可能会有细微的差别
						所以通过分辨这些浏览器之间的差异，就能准确地判断出浏览器的版本，而几乎不会报错，这种方法比读取UserAgent要准确得多
						http://www.thespanner.co.uk/2009/01/29/detecting-browsers-javascript-hacks/

					3.2.2.4识别用户安装的软件
						知道了用户使用的浏览器、操作系统后，进一步可以识别用户安装的软件
						在IE中，可以通过判断ActiveX控件的classid是否存在，来推测用户是否安装了该软件
						这种方法很早就被用于挂马攻击——黑客通过判断用户安装的软件，选择对应的浏览器漏洞，最终达到植入木马的目的
						浏览器的扩展与插件也能被XSS Payload扫描出来

					3.2.2.5CSS History Hack
						通过CSS，可以发现用户曾经访问过的网站
						这个技巧最早被Jeremiah Grossman发现，其原理是利用style的visited属性，如果用户曾经访问过某个链接，那么这个链接的颜色会变得与众不同

					3.2.2.6获取用户的真实IP地址
						通过XSS Payload还有办法获得一些客户端的本地IP地址
						很多时候，用户电脑使用了代理服务器，或者在局域网中隐藏在NAT后面，网站看到的客户端IP地址是内网的出口IP地址，而并非用户的真实IP地址
						JavaScript本身并没有提供获取本地IP地址的能力
						XSS攻击需要借助第三方软件来完成
						可以借助以上两点结合第三方软件使用，获得用户IP地址
							http://decloak.net/decloak.html

				3.2.3XSS攻击平台
					Attack API
						http://code.google.com/p/attackapi/
						由安全研究者pdp所主导的一个项目，它总结了很多能够直接使用XSS Payload，归纳为API的方式
						e.g.
							获取客户端本地信息的API(3.2.2)
					BeEF
						http://www.bindshell.net/tools/beef/
						BeEF曾经是最好的XSS演示平台
						它演示的是一个完整的XSS攻击过程
						BeEF有一个控制后台，攻击者可以在后台控制前端的一切
						每一个被XSS攻击的用户都将出现在后台，后台控制者可以控制这些浏览器的行为，并可以通过XSS向这些用户发送命令
					XSS- Proxy
						是一个轻量级的XSS攻击平台，通过嵌套iframe的方式可以实时地远程控制被XSS攻击的浏览器
					这些XSS攻击平台有助于深入了解XSS的原理及危害

				3.2.4XSS Worm
					#一种蠕虫病毒
					3.2.4.1Samy Worm
						用户之间发生交互行为的页面如果存在存储型XSS，则会比较容易发起XSS Worm攻击
						http://namb.la/popular/tech.html

					3.2.4.2百度空间蠕虫
						http://security.ctocio.com.cn/securitycomment/57/7792057.shtml

					以上两个蠕虫并不是恶意的蠕虫，真正可怕的蠕虫是那些在无声无息地盗取用户的敏感信息的蠕虫，然而这些蠕虫并不会干扰用户的正常使用，非常隐蔽

				3.2.5调试JavaScript
					想写好XSS Payload，需要有很好的JavaScript功底，调试JavaScript也是必不可少的技能
					工具
						Firebug
							这是最常用的脚本调试工具，前端工程师于Web Hacking必备，被誉为 居家旅行的瑞士军刀
							Firebug非常强大，它有好几个面板，可以查看页面的DOM节点
						IE 8 Developer Tools
							在IE8中，为开发者内置了一个JavaScript Debugger，可以动态调试JavaScript
						Fiddler
							这是一个本地代理服务器，需要将浏览器设置为使用本地代理服务器上网才可使用
							它会监控所有浏览器请求，并有能力在浏览器请求中插入数据
							它支持脚本编程，一个强大的Fiddler脚本将非常有助于安全测试
							http://www.fidder2.com/fidder2/
						HttpWatch
							这是一个商业软件，它以插件的形式内嵌在浏览器中
							它并不能调试JavaScript，它仅仅是一个专业针对Web的Sniffer
					[工具只是辅助，并不起关键作用]

				3.2.6XSS构造技巧
					3.2.6.1利用字符编码
						百度收藏
							将%c1\组成新的Unicode字符这样%c1把转运符号 \ 隐藏起来了，从而绕过了系统的安全检查，实施了XSS攻击

					3.2.6.2绕过长度限制
						很多时候，产生XSS的地方会有变量的长度限制，这个限制可能是服务器端逻辑造成的
						攻击者可以利用事件(Event)来缩短所需要的字节数
						最好的办法是把XSS Payload写到别处，再通过简短的代码加载这段XSS Payload
						最常用的一个藏代码的地方，就是location.hash，而且根据HTTP协议，location.hash的内容不会在HTTP包中发送，所以服务器端的Web日志中并不会记录location.hash中的数据，从而也更好地隐藏了黑客真实点意图
						因为location.hash的第一个字符是#，所以必须去除第一个字符才可运行
						location.hash本身没有长度限制，但是浏览器的地址栏是有长度限制的，不过这个长度已经足够用来写很长的XSS Payload了
						如果地址栏了长度不够用，还可以再使用加载远程JS的方法，来写更多代码
						在某些环境下，可以通过注释符绕过长度限制

					3.2.6.3使用<base>标签
						<base>标签并不常用，它的作用是定义页面上的所有使用相对路径标签的hosting地址
						需要特别注意的是，在有技术的文档中，提到<base>标签只能用在<head>标签内，其实这是不对的，<base>标签可以出现在HTML脚本的任意位置并作用于位于标签之后的所有标签
						所有在设计XSS安全方案时，一定要过滤掉这个非常危险的标签

					3.2.6.4window.name的妙用
						window.name对象是一个很神奇的东西，对当前窗口的window.name对象赋值，没有特殊的字符限制，因为window对象是浏览器的窗体，而并非document对象，因此很多时候window对象不受同源策略的限制，攻击者利用这个对象，可以实现跨于、跨页面传递数据，在某些环境下，这种特性将变得非常有用
						使用window.name可以缩短XSS Payload的长度
						在同一窗口打开XSS的站点后，只需通过XSS执行相应的代码即可
						这个技巧为安全研究者loulou所发现
							《突破XSS字符数量限制执行任意JS代码》
								http://secinn.appspot.com/pstzine/read?issue=3&articleid=4

				3.2.7Mission Impossible
					从XSS漏洞利用的角度看，存储型XSS对攻击者的用处比反射型XSS要大，因为存储型XSS在用户访问正常URL时会自动触发，而反射型XSS会修改一个正常的URL，一般要求攻击者将XSS URL发送给用户点击，无形中提高了攻击门槛
					有的XSS漏洞被认为只能攻击自己，称之为鸡肋漏洞

					3.2.7.1Apache Expect Header XSS
						这个漏洞最早公布于2006年，这个漏洞曾一度被认为是无法利用的所以厂商不认为这是个漏洞
						这个漏洞的影响范围是Apache Expect Header版本1.3.34、2.0.57、2.2.1及以下
						利用过程
							向服务器提交后返回
							注意到服务器在出错返回时，会把Expect头的内容未经任何处理便写入到页面中，因此Expect头中的代码就会被浏览器解析执行
						从攻击过程可以看出，需要在提交请求时向HTTP头中注入恶意数据，才能触发漏洞，但对于XSS攻击来说，JavaScript工作渲染后的浏览器环境中，无法控制用户浏览器发出的HTTP头，因此，这个漏洞曾一度被认为是鸡肋漏洞
						后来，安全研究者Amit Klein提出了使用Flash构造请求的方法，成功地利用这个漏洞，变废为宝
							在发送Flash中的HTTP请求时，可以自定义大多数的HTTP头

					3.2.7.2Anehta的回旋镖
						反射型XSS也有可能像存储型XSS一样利用
							将要利用的反射型XSS嵌入一个存储型XSS中
						这个攻击方法曾经在未知安全研究者实现的一个XSS攻击平台(Anehta)中使用过，他将其命名为回旋镖
						因为浏览器同源策略的原因，XSS也受到同源策略的限制
							发生在A域上的XSS很难影响B域的用户
						思路
							如果在B域上存在一个反射型XSS_B，在A域上存在一个存储型XSS_A，当用户访问A域上的XSS_A时，同时嵌入B域上的XSS_B，则可达到在A域的XSS攻击B域用户的目的

				3.2.8Flash XSS
					Flash中同样也有可能造成XSS攻击
					ActionScript是一种非常强大和灵活的脚本，甚至可以使用它发起网络连接，因此应该尽可能地禁止用户能够上传或加载中定义的Flash文件
					如果仅仅是视频文件，则要求转码为flv文件，flv文件是静态文件，不会产生安全隐患
					如果是带动态脚本的Flash，则可以通过Flash的配置参数进行限制
					限制Flash动态脚本的最重要的参数是allowScriptAccress，这个参数定义了Flash能否与HTML页面进行通信
						always - 对与HTML的通信也就是执行JavaScript不做任何限制
						sameDomain - 只允许来自于本域的Flash域HTML通信，这是默认值
						never - 绝对静止Flash域HTML的通信
						使用always是非常危险的，一般推荐使用never，如果值为sameDomain的话，{必须确保Flash文件不是用户上传的}
					除了allowScriptAccress外，allowNetworking也非常关键，这个参数能控制Flash与外部网络进行通信
						all - 允许使用所有的网络通信，这是默认值
						internal - Flash不能与浏览器通信，但可以调用其他API
						none - 禁止任何的网络通信
						一般建议此值设置为none或internal，设置为all可能带来安全问题
					除了用户的Flash文件能够实施脚本攻击外，一些Flash也可能会产生XSS漏洞
					安全研究者Stefano Di Paola曾经写了一个叫SWFIntruder的工具来检测产生在Flash里的XSS漏洞，通过这个工具可以检测出很多注入Flash变量导致的XSS问题
						https://www.owasp.org/index.php/Category:SWFIntruder
					Flash XSS往往被开发者所忽视，注入Flash变量的XSS，因为其原因出现在编译后的Flash文件中，一般的扫描工具或者代码审计工具都难以检查，常常使其成为漏网之鱼
					OWASP为Flash安全研究设立了一个Wiki页面
						https://www.owasp.org/index.php/Category:OWASP_Flash_Security_Project

				3.2.9JavaScript开发框架
					一般来收成熟的JavaScript开发框架都会注意自身的安全问题，但代码是人写的，高手难免也会犯错，一些JavaScript开发框架也曾暴露过一些XSS漏洞
					Dojo
						Dojo是一个流行的JavaScript开发框架，它曾被发现有XSS漏洞
							在Dojo1.4.1中，存在两个DOM型XSS
					YUI
						翻翻YUI的bugtracker也可以看到类似Dojo的问题
					jQuery
						jQuery可能是目前最流行的JavaScript框架，它本身出现的XSS漏洞很少，但开发者该记住的是，JavaScript框架只是对JavaScript语言本身的封装，并不能解决代码逻辑上产生的问题，所以开发者的意识才是安全编码的关键所在

			「3.3XSS防御」
				3.3.1HttpOnly
					HttpOnly是由微软最早提出的并在IE6中实现，至今已经逐渐成为一个标准，浏览器将禁止页面的JavaScript访问带有HttpOnly属性的Cookie
					以下浏览器开始支持HttpOnly
						Microsoft IE 6 SP1+
						Mozilla Firefox 2.0.0.5+
						Mozilla Firefox 3.0.0.6+
						Google Chrome
						Apple Safari 4.0+
						Opera9.5+
					严格来说，HttpOnly并非为了对抗XSS，它是解决XSS后的Cookie劫持攻击
						原理*见3.2.1*
							如果Cookie设置了HttpOnly，则这种攻击会失败，因为JavaScript读取不到Cookie的值
					一个Cookie的使用过程如下
			            1. 浏览器想服务器发起请求，这时候没有Cookie
			            2. 服务器发挥时发送Set- Cookie头，向客户端浏览器写入Cookie
			            3. 在该Cookie到期前，浏览器访问该域下的所有页面，都将发送该Cookie
					{服务器可能会设置多个Cookie(多个key-value对)，而HttpOnly可以有选择性地加在任意一个Cookie值上}
					在某些时候，应用可能需要JavaScript访问某几项Cookie，这种Cookie可以不设置HttpOnly标记，而仅把HttpOnly标记给用于认证的Cookie添加HttpOnly的过程简单，效果明显，有如四两拔千斤，但部署时需要注意如果业务非常复杂，则需要在所有Set-Cookie的地方，给关键Cookie都加上HttpOnly，漏掉了一个地方，都可能是使得这个方案失效
					使用HttpOnly有助于缓解XSS攻击，但仍然需要其他能够解决XSS漏洞的方案

				3.3.2输入检查
					常见的Web漏洞如XSS、SQL Injection等，都要求攻击者构造一些特殊字符，这些特殊字符可能是正常用户不会用到的，所以输入检查就有存在的必要了
					输入检查在很多时候也被用于格式检查
					这些格式检查有一点像白名单，也可以让一些基于特殊字符的攻击失效
					输入检查的逻辑，必须放在服务器端代码中实现，如果只是在客户端使用JavaScript进行输入检查，是很容易被攻击者绕过的
					目前的Web开发的普遍做法，是同时在客户端使用JavaScript中和服务器端代码中实现相同的输入检查
						客户端JavaScript的输入检查可以阻挡大部分误操作的用户，从而节约服务器资源
					在XSS防御上，输入检查一般是检查用户输入的数据中是否包含一些特殊字符,如果发现存在特殊字符，则将这些字符过滤或编码
						特殊字符e.g.
							<
							>
							'
							"
					比较智能的输入检查可能匹配XSS的特征，如<script>、javascript
					这种输入检查的方式被称为XSS Filter，互联网上有很多开源的XSS Filter的实现
					XSS Filter在用户提交数据时获取变量，并进行XSS检查，但此时用户数据并没有结合渲染页面的HTML代码，因此XSS Filter对语境的理解并不完整
					如果是一个全局性的XSS Filter，则无法看到用户数据的输出语境，而只能看到用户提交了一个URL，就很可能会漏报
						大多数情况下，URL是一种合法的用户数据
					XSS Filter还有一个问题
						其对于<、>的处理可能会改变用户数据的语义
					对于XSS Filter来说，发现敏感字符<，如果其不够智能，粗暴地过滤或者替换了<，则可能会改变用户原本的意思
					输入数据还可能会被展示在多个地方，每个地方的语境可能各不相同，如果使用单一的替换操作，则可能出现问题
					e.g.
						用户昵称会在很多地方展示，每个界面的语境也可能各不相同如果在输入时做了统一的更改，那么输出时可能有如下的问题
					------------------ 
					我的偶像是\"金智宸\"
					我的偶像是"金智宸"
					------------------
					然而第一个结果显然是用户不希望看到的
					[我也不喜欢看到第一种]

				3.3.3输出检查
					3.3.3.1安全编码函数
						编码分为很多种，针对HTML代码的编码方式是HtmlEncode
						HtmlEncode并非专用名词，它只是一种函数的实现，它的作用是将字符转换成HTML Entities，对应的标准是ISO-8859-1
						为了对抗XSS，在HtmlEncode中要求至少转换以下字符
							&		&amp
							<		&lt
							"		&quot
							'		&#x27 或 &apos(不推荐)
							/		&#x2F
								包含反斜线是因为它可能会闭合一些HTML entity
						在PHP中，有htmlentities()和htmlspecialchars()两个函数可以满足安全要求
						JavaScript的编码方式可以使用JavascriptEncode
						JavascriptEncode于HtmlEncode的编码方式不同，它需要使用 \ 对特殊字符进行转义在对抗XSS时，还要求输出的变量必须在引号内部以避免造成安全问题
						要求使用JavascriptEncode的变量输出一定要在引号内
						没有习惯的话，只能用更加严格的JavascriptEncode函数来保证安全
							除了数字、字母的所以字符，都使用十六进制\xHH的方式进行编码
						在OWASP ESAPI中有一个安全的JavascriptEncode的实现，非常严格
							http://www.owasp.org/index.php/Category:OWASP_Enterprise_Security_API
						除了HtmlEncode、JavascriptEncode外，还有许多用于各种情况的编码函数，比如XMLEncode(实现与HtmlEncode相似)
																							     JSONEncode(于JavascriptEncode相似)等
						在Apache Common Lang的StringEscapeUtils里，提供了许多escape的函数
						可以在适当的情况下选用适当的函数，但编码后的数据长度可能会发生改变，从而影响某些功能在编码时需要注意这个细节，以免产生不必要的bug

					3.3.3.2只需要一种编码吗
						XSS攻击主要发生在MVC架构中的View层，大部分的XSS漏洞可以在模板系统中解决
						在python的开发架构Django自带的模板系统Django Templates中，可以使用escape进行HtmlEncode
						在正确的地方使用正确的编码方式
						对于浏览器来说，htmlparser会优先于JavaScript Parser执行，所以解析过程是被HtmlEncode的字符先被解码，然后执行JavaScript事件
						导致XSS攻击发生的原因是由于没有分清楚输出变量的语境，因此并非用了auto-escape就万事大吉了
						XSS的防御需要区分情况对待

				3.3.4正确地防御XSS
					XSS的本质还是一种HTML注入，用户的数据被当成了HTML代码的一部分执行，从而混淆了原本的语义，产生了新的语义
					如果网站使用了MVC架构，那么XSS就发生在View层——在应用拼接变量到HTML页面时产生，所以在用户提交数据处进行输入检查的方案，其实并不是在真正发生攻击的地方做防御
					想要根治XSS问题，可以列出所有XSS可能发生的场景，再一一解决
					可能存在以下场景
			            * 在HTML标签中输出
							所有在标签中输出的变量，如果未作任何处理，都可能导致直接产生XSS
							防御方法：对变量使用HtmlEncode
			            * 在HTML属性中输出
							与标签中输出的XSS相似
							防御方法：对变量使用HtmlEncode
								在OWASP EASAPI中推荐了一种更严格的HtmlEncode——除了字母、数字外，其他所有的特殊字符都被编码成HTMLEnities
			            * 在<script>标签中输出
							首先应该确保输出的变量在引号中
							攻击者需要先闭合引号才能实施XSS攻击
							防御方法：使用JavascriptEncode
			            * 在事件中输出
							与<script>输出类似
							防御方法：使用JavascriptEncode
			            * 在CSS中输出
							防御方法：尽可能禁止用户可控制的变量在<style>标签、HTML标签的style属性以及CSS文件中输出
								如果一定有这样的需求，OWASP ESAPI中推荐了encodeForCSS()函数
							原理：类似ESAPI.encoder().encodeForJavaScript()函数，除了字母、数字外的所有字符都被编码成十六进制形式(\uHH)
			            * 在地址中输出
							1.在URL的path(路径)或者search(参数)中输出
								URLEncode会将字符转换为%HH形式
									e.g.	
										空格			%20
										<			%3c
								防御方法：使用URLEncode即可
							2.整个URL能够被用户完全控制，这是URL的Protocal和Host部分是不能够使用URLEncode的，否则会改变URl的语义
								在Protocal与Host中，如果使用严格的URLEncode函数，则会吧 :// 、. 等都编码掉 
								除了javascript作为伪协议可以执行代码外，还有vbscript、dataURI等协议可能导致脚本执行
								dataURI这个伪协议是Mozilla所支持的，能够将一段代码写在URL里
								防御方法：如果变量是整个URL，则应该先检查是否以http开头(如果不是则自动添加)以保证不会出现伪协议类的XSS攻击
										   再对变量进行URLEncode

				3.3.5处理富文本
					有些时候，网站需要允许用户提交一些自定义的HTML代码，称之为富文本
					在处理富文本时，还是要回到输入检查的思路上来
						输入检查的主要问题是在检查时还不知道变量的输出语境，但用户提交的富文本数据，其语义是完整的HTML代码，在输出时也不会\n				
					拼凑到某个标签的属性中，因此可以特殊情况特殊处理
					在*3.3.4*中，列出了所有在HTML中可能执行脚本的地方，而一个优秀的XSS Filter，也应该能够找出HTML代码中所有可能执行脚本的地方
					HTML是一种结构化的语言，比较好分析，通过htmlparser可以解析出HTML代码的标签、标签属性和事件
					在过滤富文本时，事件应该被严格禁止，因为富文本的展示需求里不应该包括事件这种动态效果，而一些危险的标签，如<iframe>、<scroipt>、<base>、<from>等，也是应该严格禁止的对象
					在标签的选择上，{应该使用白名单，避免使用黑名单}
						e.g.
							<a>、<img>、<div>等比较安全的标签
					在富文本过滤中，处理CSS也是一件麻烦的事情，如果允许用户自定义CSS、style，则也可能导致XSS攻击，因此尽可能禁止用户自定义CSS与style
					如果一定要允许用户自定义样式，则只能像过滤富文本一样过滤CSS
					有一些比较成熟的开源项目，实现了对富文本的XSS检查
					Anti-Samy是OWASP上的一个开源项目，也是目前最好的XSS Filter，最早的时候，它是基于Java的，现在已扩展到.NET等语言
						https://www.owasp.org/index.php/Category:OWASP_AntiSamy_Project
					在PHP中，可以使用另外一个广受好评的开源项目：HTMLPurify
						http://htmlpurifier.org/

				3.3.6防御DOM Based XSS
					在button的onclock事件中，执行了定义的一个函数，将HTML代码写入DOM节点，最后导致XSS的发生
					事实上，DOM Based XSS是从JavaScript中输出数据到HTML页面里，而前面提到的方法都是针对从服务器应用直接输出到HTML页面的XSS漏洞，因此并不适用于DOM型XSS
					防御方法：从JavaScript输出到HTML页面，也相当于一次XSS输出到过程，需要分语境使用不同的编码函数
					以下几个地方是JavaScript输出到HTML页面的必经之路
						document.write()
							[
								页面载入过程中用实时脚本创建页面内容，以及用延时脚本创建本窗口或新窗口的内容，在document被加载完后调用docuemnt.write方法时将会自动去触发document.open()
								在载入页面后，浏览器输出流自动关闭，在此之后，任何一个对当前页面进行操作的document.write()方法将打开一个新的输出流，它将清除当前页面内容(包括源文档的任何变量或值)
							]
							[document.open()：打开一个新文档，即打开一个流，并擦除当前文档的内容]
						document.writeln()
						xxx.innerHTML = 
						xxx.outerHTML = 
						innerHTML.replace
							[innerHTML：获取或替换html中的内容]
						document.attachEvent()
						window.attachEvent()
							[通过window.attachEvent()监听小事件]
						document.location.replace()
							[replace()：用一个新文档取代当前文档]
						document.location.assign()
							[assign()：加载一个新的文档]
						……
						需要重点关注这几个地方的参数是否可以被用户控制
					除了服务器端直接输出变量到JavaScript外，还有几个地方可能会成为DOM型XSS的输入点，也需要重点关注
						页面中所有的inputs框
						window.location(href、hash等)
							[window.location ：用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面]
						window.name
							[window.name：当前window的名称]
						document.referrer
							[document.referrer：返回一个url，当前页面就是从这个 URI 所代表的页面跳转或打开的]
						document.cookie
						localstorage
							[localstorage属性允许在浏览器中存储 key - value 对的数据]
						XMLHttpRsquest返回的数据
							[XMLHttpRsquest是一组API函数集，可被JavaScript、JScript、VBScript以及其它web浏览器内嵌的脚本语言调用，通过HTTP在浏览器和web服务器之间收发XML或其它数据]
						……
						安全研究者Stefano Di Paola设立了一个DOM型XSS的cheatsheet
							http://code.google.com/p/domxsswiki

				3.3.7不同角度看XSS的风险
					一般来说，存储型XSS的风险会高于反射型XSS，因为存储型XSS会保存在服务器上，有可能跨网站存在它不改变url的原有结构，因此有时候还能逃过一些IDS的检测
					从攻击过程来说，反射型XSS一般要求攻击者诱使用户点击一个包含XSS代码的URL链接，而存储型XSS只需要让用户浏览一个正常的URL链接
					从风险的角度来看，用户之间有互动的页面，是可能发起XSS Worm攻击的地方，而根据不同页面的PageView高低，也可以分析出哪些页面受XSS攻击后影响会更大

			「3.4总结」
				理论上，XSS漏洞虽然复杂，但却是可以彻底解决的，在设计XSS解决方案时，应该深入理解XSS攻击的原理，针对不同的场景使用不同的方法，同时有很多开源项目为我们提供了参考
				[
					过滤输入的数据，包括'、"、<、>等特殊字符
					对输出到页面的数据进行相应的编码转换，包括HTMl实体编码、JavaScript编码等
				]

		「第四章」跨站点请求伪造(CSRF)
			[
				绕过Referer
				0x00Refere为空条件下
					利用ftp://,http://,https://,file://,javascript:,data:这个时候浏览器地址栏是file://开头的，如果这个HTML页面向任何http站点提交请求的话，这些请求的Referer都是空的
					e.g.
						利用data协议
						bese64编码
						解码即可看到代码
						利用https协议
				0x01判断Referer是某域情况下绕过
					比如你找的csrf是xxx.com验证的referer是验证的*.xx.com可以找个二级域名之后<img "csrf地址">之后在把文章地址发出去就可以伪造
				0x02判断Referer是否存在某关键词
					referer判断存在不存在google.com这个关键词
					在网站新建一个google.com目录 把CSRF存放在google.com目录,即可绕过
				0x03判断referer是否有某域名
					判断了Referer开头是否以126.com以及126子域名不验证根域名为126.com 那么我这里可以构造子域名x.126.com.xxx.com作为蠕虫传播的载体服务器，即可绕过
			]
			[
				Referer防御CSRF原理
					HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器基此可以获得一些信息用于处理,当用户点击被构造好的CSRF利用页面，那么在执行用户对应操作时，提交的HTTP请求中就有对应的Referer值，此时服务端判断Referer值是否与服务器的域名信息有关,如果不相关则不执行操作
				Referer防御代码编写
					在PHP中使用 $_SERVER[‘HTTP_REFERER’] 获取页面提交请求中的Referer值
					<?php if(strpos($_SERVER['HTTP_REFERER'],'xx.com') !== false) { 判断成功 } else { 判断失败 } ?>
				绕过Referer技巧
					如果服务端只判断当前的Referer中是否具有域名，那么直接可以新建文件夹进行绕过
				Burpsutie自动生成POC
			]

			「4.1CSRF简介」
				CSRF(Cross Site Request Forgery)
					跨站点请求伪造
					它是一种常见的攻击方式，但很多开发者对它很陌生，CSRF也是Web安全中最容易被忽略的一种攻击方式，甚至很多安全工程师都不理解它的利用条件与危害，因此不给予重视
					但CSRF在某些时候却能够产生强大的破坏性

			「4.2CSRF进阶」
				4.2.1浏览器说Cookie策略
					攻击者伪造的请求之所以能被搜狐服务器验证通过，是因为用户的浏览器成功发送了Cookie的缘故
					浏览器所持有的Cookie分为两种
						1.Session Cookie
							又称临时Cookie
						2.Third-party Cookie
							又称本地Cookie
						Third-party Cookie是服务器在Set-Cookie时指定了Expire时间，只有到了Expire时间后Cookie才会生效，所以这种Cookie会保存在本地
						Session Cookie则没有指定Expire时间，所以浏览器关闭后，Session Cookie就失效了
					如果浏览器从一个域的页面中要加载另一个域的资源，由于安全原因，某些浏览器会组织Third-party Cookie的发送
						IE出于安全考虑，默认禁止了浏览器在<img>、<iframe>、<script>、<link>等标签中发送第三方Cookie
						在Firefox中，默认策略是允许发送第三方Cookie的
					在当前的主流浏览器中，默认会拦截Third-party Cookie的有：
						IE6、IE7、IE8、Safari
					不会拦截的有：
						Firefox2、Firefox3、Opera、Google Chrome、Android等
					但若CSRF攻击的目标并不需要使用Cookie，则也不需要顾虑浏览器的Cookie策略了

				4.2.2P3P头的副作用
					尽管有些CSRF攻击实施起来不需要认证，不需要发送Cookie，但是不可否认的是，大部分敏感或重要的操作是躲藏在认证之后的，因此浏览器拦截第三方Cookie的发送，在某种程度上来说，降低了CSRF攻击的威力，可是这一情况在P3P头介入后变得复杂起来
					P3P Header(The Platform For Privacy Preferences)是W3C制定的一项关于隐私的标准
						隐私偏好平台
					如果网站返回给浏览器的HTTP头中包含有P3P头，则某种程度上来说，将允许浏览器发送第三方Cookie
					在网站的业务中，P3P头主要用于类似广告等需要跨域访问的页面，但是，很遗憾的是，P3P头设置后对于Cookie的影响将扩大到整个域中的所有页面，因为Cookie是以域和path为单位的，这并不符合最小权限原则
					P3P的策略看起来似乎很难懂，但其实语法很简单，都是一一对应的关系，可以查询W3C标准
						e.g.
							CP			Compact Policy
							CURa		<current/>
							a			always
						http://www.w3.org/TR/P3P/
					P3P头也可以直接引用一个XML策略文件
					正因为P3P头目前在网站的应用中被广泛应用，因此在CSRF的防御中不能依赖于浏览器对第三方Cookie的拦截策略，不能心存侥幸

				4.2.3GET/POST
					在CSRF攻击流行之初，许多人认为CSRF攻击只能有GET请求发起，因此很多开发者都认为只要把重要的操作改成只允许POST请求，就能防止CSRF
					形成错误观点的原因主要在于大多数CSRF攻击发起时，使用的HTML标签都是<img>、<iframe>、<script>等带src属性的标签，这类标签只能发起一次GET请求，但不能发起POST请求
					在禁止GET请求时的攻击方法
						1.在页面中构造好一个from表单，然后使用JavaScript自动提交这个表单
						2.将这个页面隐藏在一个看不见的iframe窗口中，那么整个自动提交表单的过程对于用户来说也是看不见的
						3.安全研究者pdp展示了一个Gmail CSRF漏洞攻击过程
							用户登录Gmail账户，一边浏览器获得Gmail的临时Cookie
							诱使用户访问一个恶意页面，在这个恶意页面中，隐藏了一个iframe，该iframe的地址指向pdp写的CSRF构造页面
								这个链接实际就是把参数生成一个POST的表单，并自动提交
							由于浏览器中已经存在Gmail的临时Cookie，所有用户在iframe中对Gmail发起的这次请求会成功
							此时，邮箱的Filter中会新创建一条规则，将所有带附件的邮件都转发到攻击者的邮箱中

				4.2.4Flash CSRF
					Flash中也有很多种方式能够发起网络请求，包括POST
					除了URLRequest外，在Flash中还可以使用getURL，loadVars等方式发起请求
					在IE6、IE7中，Flash发送的网络请求均可以带上本地Cookie，但IE8起，Flash发起的网络请求已经不再发送本地Cookie了

				4.2.5CSRF Worm
					国内的安全组织80sec公布了一个百度的CSRF Worm
						漏洞出现在百度用户中心的发送短消息功能中
							只需要修改参数sn，即可对指定用户发送短消息
							然而百度的另一个接口则能查询出某个用户的所有好友
						将两者结合起来，可以组成一个CSRF Worm
							让一个百度用户查看一个恶意页面后，将给他的所有好友发送一条短消息，这条短消息中包含一张图片，其地址在次指向CSRF页面，使得这些好友再次将消息发送给他的好友
			            - 模拟服务器端取得request的参数
							定义蠕虫页面服务器地址，取得？、&符号后的字符串，从URL中提取感染蠕虫的用户名和感染者好友的用户名
			            - 好友json数据的动态获取
							通过CSRF漏洞从远程加载受害者的好友json数据，根据该接口的json数据格式，提取好友数据为蠕虫的传播流程做准备
			            - 感染信息输出和消息发送的核心部分
							将感染者的用户名和需要传播的好友用户名放到入错那个链接内，输出短信息
					这个蠕虫很好地展示了CSRF的破坏性，即使没有XSS漏洞，仅仅依靠CSRF，也是能够发起

			「4.3CSRF防御」
				4.3.1验证码
					CSRF攻击的过程往往是在用户不知情的情况下构造了网络请求，然而验证码则强制用户必须与应用进行交互，才能完成最终请求
					验证码只能作为防御CSRF攻击的一种辅助手段，而不能作为最主要的解决方案

				4.3.2Referer Check
					Referer Check在互联网中最常见的应用就是防止图片盗链
					同理，Referer Check也可以被用于检查请求是否来自合法的源
					常见的互联网应用，页面与页面之间都具有一定的逻辑关系，这就使得每个正常请求的Referer具有一定的规律
					即使我们能够通过检查Referer是否合法来检查用户是否被CSRF攻击，也仅仅是满足了防御的充分条件
					{Referer Check的缺陷在于服务器并非什么时候都能取到Referer}
					在Flash的一些版本中，曾经可以发送自定义的Referer头，虽然Flash在新版本中已经加强了安全限制，不再允许发送自定义的Referer头，但是难免不会有别的客户端插件允许这种操作
					出于以上种种原因，我们还是无法依赖于Referer Check作为防御CSRF的主要手段，但是通过Referer Check来监控CSRF的发生却是一种可行的方案

				4.3.3Anti CSRF Token
					4.3.3.1CSRF的本质
						CSRF攻击成功的原因
							{重要操作的所有参数都是可以被攻击者猜测到的}
						攻击者只有预测出URL的所有参数与参数值，才能成功地构造一个伪造的请求，反之，攻击者将无法完成攻击
						出于以上原因，可以想到一个解决方案
							把参数加密，或者使用一些随机数，从而让攻击者无法猜测到参数值  *1.7白帽子兵法——不可预测性原则*
						在攻击者不知道salt的情况下，是无法构造出这个URL的，因此也就无法发起CSRF攻击了
						对于服务器来说，可以从Session或Cookie中取得username = name的值，再结合salt对整个请求进行验证，正常请求会被认为是合法的
						但这个方法也有其对应的问题
							加密后的URL对用户不友好
							加随机数后的URL用户不能收藏
							普通参数加密后，数据分析会非常困难
						因此我们需要一个更加通用的解决方案——Anti CSRF Token
						要Token足够随机，必须使用足够安全的随机数生成算法，或者采用真随机数生成器(物理随机) *第十一章 加密算法与随机数*
						Token因该作为一个秘密，为用户与服务器所共同持有，不能被第三方知晓
						在实际应用时，Token可以放在用户的Session中，或者浏览器的Cookie中
						Token需要同时放在表单与Session，在提交请求时，只需验证两个Token是否一致，如果不一致(包括空Token)，则有可能发生CSRF攻击

					4.3.3.2Token的使用原则
						防御CSRF攻击的Token是根据不可预测性原则设计的方案，所以Token的生成一定要足够随机，需要使用安全的随机数生成器生成Token
						如果Token保存在Cookie中，那么如果用户同时打开多个页面同时操作时，当某个页面消耗点Token时，其他页面的Token还是原先被消耗的Token，就会产生差错
							解决方法：同时生成多个Token，一对一，更放心
						如果Token出现在某个页面的URL中，则可能会通过Referer的方式泄露
						如果页面包含了一张攻击者能指定地址的图片，则该请求地址会作为HTTP请求的Referer发送到evil.com的服务器上，从而导致Token泄露
						因此在使用Token时，因该尽量把Token放在表单中把敏感操作由GET改为POST以from表单(或者AJAX)到形式提交，可以避免Token泄露
						还有一些其他途径可能导致Token泄露，如XSS及跨域漏洞，都可以让攻击者盗取Token的值
						CSRF的Token只适用于防范CSRF攻击，当网站中还有XSS漏洞时，这个方案就会变的无效，因为XSS乐意模拟客户端浏览器执行任意操作，在XSS攻击下，攻击者完全可以请求页面后，读出页面里的Token值，然后构造一个合法的请求，此过程称之为XSRF，用以与CSRF进行区分
						XSS带来的问题，因该使用XSS的防御方案给予解决，否则CSRF的Token防御就是空中楼阁
						安全防御的体系是相辅相成、缺一不可的

			「4.4总结」
				CSRF攻击是攻击者利用用户的身份操作用户账户的一种攻击方式，设计CSRF的防御方案必须先理解CSRF攻击的原理和本质
				根据不可预测性原则，我们通常使用Anti CSRF Token来防御CSRF攻击，在使用Token时，要注意Token的保密性和随机性

		「第五章」点击劫持(ClickJacking)

			「5.1什么是点击劫持」
				安全专家Robert Hansen与Jeremiah Grossman发现了一种被他们称为ClickJacking(点击劫持)的攻击，这种攻击几乎影响了所有的桌面平台，包括IE、Safari、Firefox、Opera以及Adobe Flash
				点击劫持是一种视觉上的欺骗手段，攻击者使用一个透明的、不可见的iframe，覆盖在一个网页上，然后诱使用户在该网站上进行操作，此时用户将在不知情的情况下点击透明的iframe页面
				通过调整iframe页面的位置，可以诱使用户恰好点击阿兹iframe页面的一些功能性按钮上
				通过控制iframe的长、宽，以及调整top、left的位置，可以把iframe页面内的任意部分覆盖到任何地方，同时设置iframe的position为absolute，并将z-index的值设置为最大，以达到让iframe处于页面的最高层，再通过设置opacity来控制iframe页面的透明度，值为0是完全不可见
				点击劫持攻击与CSRF攻击 *第四章 跨站点请求伪造(CSRF)* 有异曲同工之妙，都是在用户不知情的情况下诱使用户完成一些动作，但是在CSRF攻击过程中，如果出现用户交互的页面，则攻击可能会无法顺利完成
				但是点击劫持没有这个顾虑，它利用的就是与用户产生交互的页面

			「5.2Flash点击劫持」
				攻击者通过通过Flash构造出了点击劫持，在完成一系列复杂操作下，最终控制用户电脑的摄像头
					* 攻击者制造一个Flash游戏，并诱使用户来玩此游戏
					* 该游戏就是诱使用户点击click按钮，每一次点击，这个按钮的位置都会变化
					* 在一步步操作后，打开了用户的摄像头
				其实该网页隐藏了一个iframe页面，一步步诱使用户点击功能键，从而打开摄像头

			「5.3图片覆盖攻击」
				点击劫持是一种视觉欺骗，顺着这个思路，还有一些攻击方式也可以起到类似的作用，如图片覆盖
				安全研究者sven.vetsch最先提出了这种Cross Site Image Overlaying攻击，简称XSIO
				sven.vetsch通过调整图片的style使得图片能够覆盖在他所指定的任意位置XSIO不同于XSS，它利用的是图片的style，或者能够控制CSS如果应用没有下肢style的position为absolute的话，图片就可以覆盖到页面上的任意位置，形成点击劫持
				百度空间也曾出现过此问题
					http://hi.baidu.com/aullik5/blog/item/e031985175a02c685352416.html
				图片还可以伪装得像一个正常的链接、按钮，或者在图片中构造一些文字覆盖在关键的位置，这样就不需要用户点击，也可以达到欺骗的作用
				由于<img>标签在很多系统中是对用户开放的，因此在现实中有非常多的站点存在被XSIO攻击的可能
				在防御XSIO时，需要检查用户提交的HTML代码中，<img>标签的style属性是否可能导致浮出

			「5.4拖拽劫持、数据盗取」
				安全研究者Paul Stone在BlackHat 2010大会上发表了题为Next Generation Clickjacking的演讲，在该演讲中提出了浏览器拖拽事件导致的安全问题
				目前很多浏览器都支持使用Drag & Drop的API
				对于用户来说，拖拽使他们的操作更加简单
				浏览器中的拖拽对象可以是链接、文字、窗口，因此拖拽不受同源策略的限制
				拖拽劫持的思路是诱使用户从隐藏的iframe中拖拽出攻击者希望得到的数据，然后放到攻击者能控制的另一个页面中，从而盗取数据
				在JavaScript或Java API的支持下，这个攻击过程会变得非常隐蔽，因为它突破了传统ClickJacking一些先天的局限，所以这种新型的拖拽劫持能够造成更大的破坏
				国内安全研究者xisigr曾经构造了一个针对Gmail的POC
					http://hi.baidu.com/blog/item/2c2b7a110ec848f0c2ce79ec.html

			「5.5触屏劫持」
				手机上的触屏劫持攻击被斯坦福的安全研究者公布，这意味着ClickJacking的攻击方式跟进一步，斯坦福安全研究者的将其称为TapJacking
					http://seclab.stanford.edu/websec/framebusting/tapjacking.pdf
				从手机OS的角度看，触屏实际上是一个事件，OS捕捉这些事件，并执行相应的操作
				一次触屏可能对应一下操作
					* touchstart，手指触摸屏幕时产生
					* touchend，手指离开屏幕时产生
					* touchmove，手指滑动时发生
					* touchcancel，系统可取消touch
					通过将一个不可见的iframe覆盖到当前网页上，可以劫持用户的触屏操作
					2010年12月，研发者发现TapJacking可以更改系统安全设置
					http://blog.mylookout.com/look-10-007-tapjacking/
					http://vimeo.com/17648348

			「5.6防御ClickJacking」
				5.6.1frame busting
					可以写一段JavaScript代码，禁止iframe的嵌套，这种方法叫frame busting
					但frame busting存在一些缺陷
						由于他是JavaScript写的，控制能力不是特别强，因此有许多方法饶过它
					此外，像HTML5中iframe的sandbox属性、IE中iframe的security属性等，都可以限制iframe页面中的JavaScript脚本执行，从而可以使得frame busting失效
					斯坦福的Gustav Rydstedt等人总结了一片关于攻击frame busting的paper
						http://seclab.stanford.edu/websec/framebusting/framebust.pdf

				5.6.2X-Frame-Options
					因为frame busting容易被绕过，所以我们需要一个更好的解决方案----HTTP头的X-Frame-Options
					X-Frame-Options可以说是专门为ClickJacking准备的，一下浏览器已开始支持X-Frame-Options
						* IE 8+
						* Opera 10.50+
						* Safari 4+
						* Chrome 4.1.249.1042+
						* Firefox 3.6.9(or earlier with NoScript)
					它有三个可选的值
						* DECY
							拒绝访问任何iframe
						* SAMEORIGN
							只能访问同源域名下的iframe
						* ALLOW-FROM Origin
							允许frame加载页面地址
				[
					Content Security Policy
					网页安全政策(CSP(Content Security Policy))，一种白名单制度
				]

			「5.7总结」
				XSS与CSRF需要诱使用户与界面产生交互，而ClickJacking在未来仍然有可能被攻击者利用在钓鱼、欺诈、广告作弊等方面，不可不察

		「第六章」HTML5安全
			[
				浏览器支持
					微软MIX10技术大会上宣布其推出的IE9浏览器已经支持HTML5
					Mozilla基金会发布了即将推出的Firefox4浏览器的第一个早期测试版，该版本中Firefox浏览器中进行了大幅改进，包括新的HTML5语法分析器，以及支持更多的HTML5语法分析器，以及支持更多的HTML5形式的控制等，从官方文档来看，Firefox4对HTML5是完全级别的支持
					谷歌Gears项目经理通过微博宣布，谷歌将放弃对Gears浏览器插件项目的支持，以重点开发HTML5项目，目前在谷歌看来，Gears应用用于HTML5的诸多创新非常相似，并且谷歌一直积极发展HTML5项目，因此只要谷歌不断以加强网络标准的应用功能为工作重点，那么为Gears增加新功能就无太大意义了，另外，Gears面临的需求也在日益下降，这也是谷歌做出吊证的重要原因
					苹果在开发者发布会公布Safari5，这款浏览器支持10个以上的HTML5新技术，包括全屏幕播放、HTML5视频、HTML5地理位置、HTML5切片元素、HTML5的可拖动属性、HTML5的形式验证、HTML5的Ruby、HTML5的Ajaxl.ishi和WebSocket字幕
					Opera软件公司首席技术官，号称“CSS之父”的Hakon Wium Lie认为，HTML5和CSS3，将会是全球互联网发展的未来趋势，包括目前Opera在内的诸多浏览器厂商，纷纷研发HTML5的相关产品，web未来属于HTML5
				开发工具
					Notepad++
						https://notepad-plus-plus.org/
					Visual Studio Code
						https://code.visualstudio.com/
					HBuilderX
						https://www.dcloud.io/hbuilderx.html
					Dreamweaver(收费)
						https://www.adobe.com/cn/products/dreamweaver.html
					Sublime Text(收费)
						http://www.sublimetext.com/
					Webstorm(收费)
						https://www.jetbrains.com/webstorm/
				HTML5语法
					基本结构
						--------------------------
						<!DOCTYPE html>
						<html lang="en">
						<head>
						    <meta charset="UTF-8">
						    <title></title>
						</head>
						<body>

						</body>
						</html>
						--------------------------
					语法规范
						HTML5中不区分大小写，但是我们一般都使用小写
						HTML5中的注释不能嵌套
						HTML5标签必须结构完整，要么成对出现，要么自结束标签
						HTML5标签可以嵌套，但是不能交叉嵌套
						HTML5标签中的属性必须有值，且值必须加引号(双引号单引号都可以)
					标签规范
						单标签
							-------------------------
							<标签名 [属性名=属性值,...]>
							-------------------------
						标签对
							---------------------------------
							<标签名 [属性名=属性值,...]></标签名>
							---------------------------------
				HTMl5标签
					标题标签
						-------------------
						<h1>这是一级标题</h1>
						<h2>这是二级标题</h2>
						<h3>这是三级标题</h3>
						<h4>这是四级标题</h4>
						<h5>这是五级标题</h5>
						<h6>这是六级标题</h6>
						-------------------
					段落标签
						-----------------
						<p>这是一个段落</p>
						-----------------
					链接标签
						-----------------------------------------------------
						<a href="https://www.baidu.com">打开百度，你就知道！</a>
						-----------------------------------------------------
						常见属性
							属性，值，描述
							href，URL，规定链接的目标URL
							target，_blank、_parent、_self、_top、framename，规定链接在何处打开目标URL(仅在href属性存在时使用)
					图像标签
						---------------------------------------------------------------------------------------------
						<img src="https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png" alt="百度LOGO">
						---------------------------------------------------------------------------------------------
					表格标签
						--------------------------------------------------------
						<table border="1px" cellpadding="0px" cellspacing="0px">
						    <tr>
						        <th>表头一</th>
						        <th>表头二</th>
						        <th>表头三</th>
						        <th>表头四</th>
						    </tr>
						    <tr>
						        <td>单元格一</td>
						        <td>单元格二</td>
						        <td>单元格三</td>
						        <td>单元格四</td>
						    </tr>
						</table>
						--------------------------------------------------------
					列表标签
						无序列表
							------------------
							<ul>
							    <li>列表项</li>
							    <li>列表项</li>
							    <li>列表项</li>
							    <li>列表项</li>
							</ul>
							------------------
						有序列表
							------------------
							<ol>
							    <li>列表项</li>
							    <li>列表项</li>
							    <li>列表项</li>
							    <li>列表项</li>
							</ol>

							------------------
						自定义列表
							----------------------------
							<dl>
							    <dt>+</dt><dd>列表项</dd>
							    <dt>+</dt><dd>列表项</dd>
							    <dt>+</dt><dd>列表项</dd>
							</dl>
							----------------------------
					分组标签
						------------------
						<div>具体内容</div>
						------------------
						--------------------
						<span>具体内容</span>
						--------------------
					语义标签
						常见标签
							<header>，规定文档或节的页眉
							<footer>，定义文档或节的页脚
							<main>，规定文档的主内容
							<section>，定义文档的节
							<article>，定义文档的文章
							<aside>，定义页面内容以外的内容
							<nav>，定义导航链接
							<mark>，定义重要的或强调的文本
							<figure>，规定自包含内容
							<figcaption>，定义<figure>元素的标题
							<details>，定义用户能够查找或隐藏的额外细节
							<summary>，定义<details>元素的可见标题
							<time>，定义时间
						基本布局
							------------
							<header>
							<nav>
							<section>
							<aside>
							<article>
							<footer>
					表单标签
						常见标签
							<from>，定义供用户输入的表单
							<input>，定义输入域
							<label>，定义了 <input> 元素的标签，一般为输入标题
							<textarea>，定义文本域 (一个多行的输入控件)
							<fieldset>，定义了一组相关的表单元素，并使用外框包含起来
							<legend>，定义了 <fieldset> 元素的标题
							<select>，定义了下拉选项列表
							<optgroup>，定义选项组
							<option>，定义下拉列表中的选项
							<button>，定义一个点击按钮
							<datalist>，指定一个预先定义的输入控件选项列表
							<keygen>，指定一个预先定义的输入控件选项列表
							<output>，定义一个计算结果
						演示
							form、input、label演示
								-------------------------------------------------------------
								<form action="" method="get">
								    <p>
								        <label for="username">账户：</label>
								        <input type="text" name="username" id="username">
								    </p>
								    <p>
								        <label for="password">密码：</label>
								        <input type="password" name="password" id="password">
								    </p>
								    <p><input type="submit"></p>
								</form>
								-------------------------------------------------------------
							textarea演示
								--------------------------------------------------------------
								<form action="" method="post">
								    <textarea name="mycontext" cols="30" rows="10"></textarea>
								    <input type="submit">
								</form>
								--------------------------------------------------------------
							fieldset、legend、select、optgroup、option演示
								----------------------------------------------------
								<form action="" method="post">
								    <fieldset>
								        <legend>请选择你的爱好：</legend>

								        <select name="myhobby" id="myhobby">
								            <optgroup label="运动">
								                <option value="篮球">篮球</option>
								                <option value="足球">足球</option>
								            </optgroup>
								            <optgroup label="电子">
								                <option value="看电影">看电影</option>
								                <option value="看电视">看电视</option>
								            </optgroup>
								        </select>
								    </fieldset>
								</form>
								----------------------------------------------------
							datalist演示
								------------------------------------------
								<form action="" method="post">
								    <input list="browsers">
								    <datalist id="browsers">
								        <option value="Internet Explorer">
								        <option value="Firefox">
								        <option value="Chrome">
								        <option value="Opera">
								        <option value="Safari">
								    </datalist>
								</form>
								------------------------------------------
							单选框演示
								------------------------------------------------------------------
								<form action="" method="post">
								    <input type="radio" name="sex" id="male" value="male" checked>
								    <label for="male">Male</label>

								    <input type="radio" name="sex" id="female" value="female">
								    <label for="female">female</label>
								</form>
								------------------------------------------------------------------
							复选框演示
								-----------------------------------------------------------------
								<form action="" method="post">
								    <input type="checkbox" name="vehicle" id="bike" value="bike">
								    <label for="bike">I have a bike</label>

								    <input type="checkbox" name="vehicle" id="car" value="car">
								    <label for="car">I have a car</label>
								</form>
								-----------------------------------------------------------------
						框架标签
							------------------------------------------------------------------------------------------
							<iframe src="https://www.baidu.com" frameborder="0" width="500px" height="500px"></iframe>
							------------------------------------------------------------------------------------------
						音频标签
							----------------------------------------------
							<audio controls>
							    <source src="horse.ogg" type="audio/ogg">
							    <source src="horse.mp3" type="audio/mpeg">
							    您的浏览器不支持 Audio 标签
							</audio>
							----------------------------------------------
						视频标签
							-------------------------------------------
							<video width="320" height="240" controls>
							  <source src="movie.mp4" type="video/mp4">
							  <source src="movie.ogg" type="video/ogg">
							    您的浏览器不支持 Video 标签
							</video>
							-------------------------------------------
						其他标签
							水平线：<hr>
							换行：<br>
							<b>粗体文本</b>
							<code>计算机代码</code>
							<em>强调文本</em>
							<i>斜体文本</i>
							<kbd>键盘输入</kbd>
							<pre>预格式化文本</pre>
							<small>更小的文本</small>
							<strong>重要的文本</strong>
							<abbr>缩写词或者首字母缩略词</abbr>
							<address>联系信息</address>
							<bdo>文字方向</bdo>
							<blockquote>从另一个源引用的部分</blockquote>
							<cite>工作的名称</cite>
							<del>删除的文本</del>
							<ins>插入的文本</ins>
							<sub>下标文本</sub>
							<sup>上标文本</sup>
						头部标签
							<head>，定义了文档的信息
							<title>，定义了文档的标题
							<base>，定义了页面链接标签的默认链接地址
							<link>，定义了一个文档和外部资源之间的关系
							<meta>，定义了HTML文档中的元数据
							<script>，定义了客户端的脚本文件
							<style>，定义了HTML文档的样式文件
				HTML5属性
					HTML5标签可以设置属性，属性总是以名称/值对的形式出现，如name=value，它的主要作用是控制或修饰标签
					通用属性
						accesskey，设置访问元素的键盘快捷键
						class，规定元素的类名(classname)
						contenteditable，规定是否可编辑元素的内容
						contextmenu，指定一个元素的上下文菜单，当用户右击该元素，出现上下文菜单
						data-*，用于存储页面的自定义数据
						dir，设置元素中内容的文本方向
						draggable，指定某个元素是否可以拖动
						dropzone，指定是否将数据复制，移动，或链接，或删除
						hidden，hidden 属性规定对元素进行隐藏
						id，规定元素的唯一id
						lang，设置元素中内容的语言代码
						spellcheck，检测元素是否拼写错误
						style，规定元素的行内样式(inline style)
						tabindex，设置元素的 Tab 键控制次序
						title，规定元素的额外信息(可在工具提示中显示)
						translate，指定是否一个元素的值在页面载入时是否需要翻译
				HTML5事件
					HTML5事件可以触发浏览器中的行为，比方说当用户点击某个 HTML 元素时启动一段 JavaScript
					窗口事件
						由窗口触发该事件(同样适用于 <body> 标签)
						属性，值，描述
						onafterprint，script，在打印文档之后运行脚本
						onbeforeprint，script，在文档打印之前运行脚本
						onbeforeonload，script，在文档加载之前运行脚本
						onblur，script，当窗口失去焦点时运行脚本
						onerror，script，当错误发生时运行脚本
						onfocus，script，当窗口获得焦点时运行脚本
						onhashchange，script，当文档改变时运行脚本
						onload，script，当文档加载时运行脚本
						onmessage，script，当触发消息时运行脚本
						onoffline，script，当文档离线时运行脚本
						ononline，script，当文档上线时运行脚本
						onpagehide，script，当窗口隐藏时运行脚本
						onpageshow，script，当窗口可见时运行脚本
						onpopstate，script，当窗口历史记录改变时运行脚本
						onredo，script，当文档执行再执行操作(redo)时运行脚本
						onresize，script，当调整窗口大小时运行脚本
						onstorage，script，当 Web Storage 区域更新时(存储空间中的数据发生变化时)运行脚本
						onundo，script，当文档执行撤销时运行脚本
						onunload，script，当用户离开文档时运行脚本
					表单事件
						表单事件在HTML表单中触发(适用于所有 HTML 元素，但该HTML元素需在form表单内)
						属性，值，描述
						onblur，script，当元素失去焦点时运行脚本
						onchange，script，当元素改变时运行脚本
						oncontextmenu，script，当触发上下文菜单时运行脚本
						onfocus，script，当元素获得焦点时运行脚本
						onformchange，script，当表单改变时运行脚本
						onforminput，script，当表单获得用户输入时运行脚本
						oninput，script，当元素获得用户输入时运行脚本
						oninvalid，script，当元素无效时运行脚本
						onselect，script，当选取元素时运行脚本
						onsubmit，script，当提交表单时运行脚本
					键盘事件
						通过键盘触发事件，类似用户的行为
						属性，值，描述
						onkeydown，script，当按下按键时运行脚本
						onkeypress，script，当按下并松开按键时运行脚本
						onkeyup，script，当松开按键时运行脚本
					鼠标事件
						通过鼠标触发事件，类似用户的行为
						属性，值，描述
						onclick，script，当单击鼠标时运行脚本
						ondblclick，script，当双击鼠标时运行脚本
						ondrag，script，当拖动元素时运行脚本
						ondragend，script，当拖动操作结束时运行脚本
						ondragenter，script，当元素被拖动至有效的拖放目标时运行脚本
						ondragleave，script，当元素离开有效拖放目标时运行脚本
						ondragover，script，当元素被拖动至有效拖放目标上方时运行脚本
						ondragstart，script，当拖动操作开始时运行脚本
						ondrop，script，当被拖动元素正在被拖放时运行脚本
						onmousedown，script，当按下鼠标按钮时运行脚本
						onmousemove，script，当鼠标指针移动时运行脚本
						onmouseout，script，当鼠标指针移出元素时运行脚本
						onmouseover，script，当鼠标指针移至元素之上时运行脚本
						onmouseup，script，当松开鼠标按钮时运行脚本
						onmousewheel，script，当转动鼠标滚轮时运行脚本
						onscroll，script，当滚动元素的滚动条时运行脚本
					媒体事件
						通过视频(videos)，图像(images)或音频(audio)触发该事件，多应用于HTML媒体元素比如：<embed>，<object>，<img>，<audio>和<video>
						属性，值，描述
						onabort，script，当发生中止事件时运行脚本
						oncanplay，script，当媒介能够开始播放但可能因缓冲而需要停止时运行脚本
						oncanplaythrough，script，当媒介能够无需因缓冲而停止即可播放至结尾时运行脚本
						ondurationchange，script，当媒介长度改变时运行脚本
						onemptied，script，当媒介资源元素突然为空时(网络错误、加载错误等)运行脚本
						onended，script，当媒介已抵达结尾时运行脚本
						onerror，script，当在元素加载期间发生错误时运行脚本
						onloadeddata，script，当加载媒介数据时运行脚本
						onloadedmetadata，script，当媒介元素的持续时间以及其他媒介数据已加载时运行脚本
						onloadstart，script，当浏览器开始加载媒介数据时运行脚本
						onpause，script，当媒介数据暂停时运行脚本
						onplay，script，当媒介数据将要开始播放时运行脚本
						onplaying，script，当媒介数据已开始播放时运行脚本
						onprogress，script，当浏览器正在取媒介数据时运行脚本
						onratechange，script，当媒介数据的播放速率改变时运行脚本
						onreadystatechange，script，当就绪状态(ready-state)改变时运行脚本
						onseeked，script，当媒介元素的定位属性不再为真且定位已结束时运行脚本
						onseeking，script，当媒介元素的定位属性为真且定位已开始时运行脚本
						onstalled，script，当取回媒介数据过程中(延迟)存在错误时运行脚本
						onsuspend，script，当浏览器已在取媒介数据但在取回整个媒介文件之前停止时运行脚本
						ontimeupdate，script，当媒介改变其播放位置时运行脚本
						onvolumechange，script，当媒介改变音量亦或当音量被设置为静音时运行脚本
						onwaiting，script，当媒介已停止播放但打算继续播放时运行脚本
					其他事件
						onshow,script,当<menu>元素在上下文显示时触发
						ontoggle,script,当用户打开或关闭<details>元素时触发
			]

			「6.1HTML5新标签」
				HTML5是W3C制定的新一代HTML语言的标准，这个标准现在还在不断地修改，但是主流的浏览器厂商都已经开始逐渐支持这些新功能，离HTML5真正的普及还有很长一段路要走，但是由于浏览器已经开始支持部分功能，所以HTML5的影响已经显现，可以预见到，在移动互联网领域，HTML5会有着广阔的发展前景

				6.1.1新标签的XSS
					HTML5中定义了很多新标签、新事件，可能导致新的XSS攻击
					一些XSS Filter如果建立一个黑名单的话，则可能就不会覆盖到HTML5新增的标签和功能，从而避免产生XSS
					HTML5中新增的一些标签和属性，使得XSS等Web攻击产生了新的变化，为了总结这些变化，安全研究者建立了一个HTML5 Security Cheatsheet项目
						http://code.google.com/p/html5security

				6.1.2iframe的sandbox
					<iframe>标签一直以来都为人所诟病，挂马、XSS、ClickJacking等都需运用它
					在HTML5中，专门为iframe定义了一个新的属性----sandbox使用sandbox属性后，<iframe>标签加载的内容将被视为一个独立的源，其中的脚本将被禁止执行，表单被禁止提交，插件被禁止加载，只想其他浏览对象的链接也会被禁止
					sandbox属性可以通过参数来支持更精确的控制，有以下几个值可以选择：
						* allow-same-origin，允许同源访问
						* allow-top-navigation，允许防伪顶层窗口
						* allow-forms，允许提交表单
						* allow-scripts，允许执行脚本
					可是有的行为即便是设置了allow-scripts，也是不允许的，如弹出窗口

				6.1.3Link Types：noreferrer
					在HTML5中，为<a>、<area>这两个标签定义了一个新的Link Types----noreferrer
					标签指定了noreferrer后，浏览器在请求该标签指定的地址是将不再发送Referer
					这种设计是出于保护敏感信息和隐私的考虑，因为通过Referer，可能会泄露一些敏感信息
					这个标签需要开发者手动添加到页面的标签中，对于有需要的标签可以选择使用noreferrer

				6.1.4Canvas的妙用
					Canvas是HTML5的最大创新之一
					<canvas>标签让JavaScript可以在页面中直接操作图片对象，也可以直接操作像素，构造出图片区域
					Canvas的出现极大的挑战了传统富客户端插件的地位，开发者甚至可以通过Canvas在浏览器上写一个小游戏
					一下浏览器中，开始支持<canvas>标签
						* IE 7+
						* Firefox 3.0+
						* Safari 3.0+
						* Chrome 3.0+
						* Opera 10.0+
						* iPhone 1.0+
						* Android 1.0+
					Dive Into HTML5很好地介绍了Canvas及其他HTML5的特性
						http://diveintohtml.info/canvas.html
					Canvas提供的强大功能，甚至可以破解验证码，Shaun Firedle写了一个GreaseMonkey的脚本，通过操作Canvas中的每一个像素点，成功地识别了Megaupload提供的验证码
						http://userscript.org/scripts/review/38736
					HTML5使过去难以做到的事情变得可能

			「6.2其他安全问题」
				6.2.1Cross-Origin Resource Sharing
					浏览器实现的同源策略限制了脚本的跨域请求，但互联网的发展趋势是越来越开放的，因此跨域访问的需求也变得越来越迫切，同源策略给Web开发者带来了很多困扰，他们不得不想方设法地实现一些合法的跨域技术，由此诞生了jsonp、iframe跨域等技巧
					W3C委员会决定制定一个新的标准来解决日益迫切的跨域访问问题
						http://www.w3.org/TR/cors/
					Origin Header用于标记HTTP发起的源，服务器端通过识别浏览器自动带上端这个Origin Header，来判断浏览器的请求是否来自一个合法的源，Origin Header可以用于防范CSRF，它不像Referer那么容易被伪造或清空

				6.2.2postMessage——跨窗口传递信息
					*第三章 跨站脚本攻击(XSS)*中提到window.name几乎不受同源策略限制
					{postMessage允许每一个window对象往其他的窗口发送本地信息，从而实现跨窗口的消息传递，这个功能是不受同源策略限制的}
					使用时的注意事项
						* 在必要时，可以接收窗口验证Oomain，甚至验证URL，以防来自非法页面的消息，这实际上是在代码中实现一次同源策略的验证过程
						* 如果将消息写入innerHTML。甚至直接写入script中，可能导致DOM型XSS产生，根据Secure By Default原则，在接受窗口不应该信任接收到的消息，需要对消息进行安全检查
					使用postMessage也会让XSS Payload变得更加灵活，Gareth Heyes曾经实现过一个JavaScript运行环境的sandbox，其原理是创建一个iframe，将JavaScript限制于其中执行
					但通过研究发现，利用postMessage()给父窗口发消息可以突破sandbox

				6.2.3Web Storage
				过去浏览器的储存方式哟有以下几种
					* Cookie
						主要用于保存登录凭证和少量信息
					* Flash Shared Object
						是Adobe自己的功能
					* IE UserData
						是微软自己的功能
				W3C委员会希望能在客户端有一个强大和方便的本地储存功能，就是Web Storage
				Web Storage分为Session Storage和Local Storage
					Session Storage
						关闭浏览器就会失效
					Local Storage
						会一直存在
				Web Storage就像一个非关系型数据库，由Key - Value对组成，可以通过JavaScript对其进行操作
					设置一个值 = window.sessionStorage.setItem(key,value)
					读取一个值 = window.sessionStorage.getItem(key)
				Web Storage也收到同源策略的约束，每个域所拥有的信息只会保存在自己的域下
				Web Storage让Web开发更加灵活多变，它的强大功能也为XSS Payload打开方便之门，攻击者有可能将恶意代码保存在Web Storage中，从而实现跨页面攻击
				当Web Storage存有敏感信息时，也可能成为攻击目标，而XSS攻击正好能够实现这一过程
				可以预见，Web Storage会被越来越多的开发者所接受，也会带来更多安全挑战

			「6.3总结」
				HTML5是互联网未来的大势所趋，虽然目前距离全面普及还有很长的路要走，但随着浏览器开始支持越来越多的HTML5功能攻击面也随之产生了新的变化，攻击者有可能利用HTML5的特性，来绕过未及时更新的防御方案，要对抗这些新型的攻击，就必须了解HTML5的方方面面
				对与HTML5来说，在移动互联网的普及进程可能会快一些，因此未来HTML5攻防的主战场，很可能会发生在移动互联网上
